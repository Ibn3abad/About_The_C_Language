# **Cلنتعلم لغة البرمجة** 

الجمهور: هذا الكتاب للمبتدئين فقط.

**فهرس**

[1 **نظرة عامة**](#نظرة-عامة)	  
[1.1 لماذا نستخدم C؟     	   7](#لماذا-نستخدم-c؟)  
[1.1.1 *الكفاءة والسرعة العالية (Speed And Efficiency)*     	   7](#الكفاءة-والسرعة-العالية-\(speed-and-efficiency\))  
[1.1.2 *التحكم المباشر في العتاد (Direct Hardware Access)*     	   8](#التحكم-المباشر-في-العتاد-\(direct-hardware-access\))  
[1.1.3 *الأنظمة المدمجة (Embedded Systems)*     	   8](#الأنظمة-المدمجة-\(embedded-systems\))  
[1.1.4 *"لغة اللغات" (The Mother Of All Languages)*     	   8](#"لغة-اللغات"-\(the-mother-of-all-languages\))  
[1.1.5 *قابلية النقل (Portability)*     	   8](#قابلية-النقل-\(portability\))  
[2 **إعداد البيئة**](#إعداد-البيئة)	  
[2.1 جربه عبر الإنترنت     	   10](#جربه-عبر-الإنترنت)  
[3 **هيكل البرنامج**](#هيكل-البرنامج)	  
[3.1  مرحبا بالعالم „Hello World“     	   11](#مرحبا-بالعالم-„hello-world“)  
[3.2 تجميع وتنفيذ برنامج C     	   12](#تجميع-وتنفيذ-برنامج-c)  
[4 **بناء الجملة الأساسي**](#بناء-الجملة-الأساسي)	  
[4.1 الرموز في لغة C     	   13](#الرموز-في-لغة-c)  
[4.2 الفواصل المنقوطة     	   13](#الفواصل-المنقوطة)  
[4.3 تعليقات     	   14](#تعليقات)  
[4.4 المعرفات     	   14](#المعرفات)  
[4.5 الكلمات الرئيسية     	   14](#الكلمات-الرئيسية)  
[4.6 المسافة البيضاء في لغة C     	   15](#المسافة-البيضاء-في-لغة-c)  
[5 **أنواع البيانات**](#أنواع-البيانات)	  
[5.1 أنواع الأعداد الصحيحة     	   17](#أنواع-الأعداد-الصحيحة)  
[5.2 أنواع النقطة العائمة Floating-Point     	   18](#أنواع-النقطة-العائمة-floating-point)  
[5.3 النوع void     	   19](#النوع-void)  
[6 **المتغيرات**](#المتغيرات)	  
[6.1 تعريف المتغير في لغة C     	   21](#تعريف-المتغير-في-لغة-c)  
[6.2 إعلان المتغيرات في لغة C     	   22](#إعلان-المتغيرات-في-لغة-c)  
[6.3 القيم L والقيم R في لغة C     	   24](#القيم-l-والقيم-r-في-لغة-c)  
[7 **الثوابت والحرفيات**](#الثوابت-والحرفيات)	  
[7.1 حرفيات الاعداد الصحيحة Interger     	   25](#حرفيات-الاعداد-الصحيحة-interger)  
[7.2 الحرف ذو الفاصلة العائمة Floating-point     	   26](#الحرف-ذو-الفاصلة-العائمة-floating-point)  
[7.3 ثوابت الأحرف     	   26](#ثوابت-الأحرف)  
[7.4 String سلسلة حرفية     	   27](#string-سلسلة-حرفية)  
[7.5 تعريف الثوابت     	   28](#تعريف-الثوابت)  
[7.5.1 *المعالج المسبق \#Define*     	   28](#المعالج-المسبق-#define)  
[7.5.2 *المفتاح Cosnt*     	   29](#المفتاح-cosnt)  
[8 **فئات التخزين**](#فئات-التخزين)	  
[8.1 فئة التخزين التلقائيauto     	   31](#فئة-التخزين-التلقائيauto)  
[8.2 فئة التخزينregister     	   31](#فئة-التخزينregister)  
[8.3 فئة التخزين static     	   32](#فئة-التخزين-static)  
[8.4 فئة التخزين extern     	   33](#فئة-التخزين-extern)  
[9  **المشغلين Operators**](#المشغلين-operators)	  
[9.1 العمليات الحسابية     	   35](#العمليات-الحسابية)  
[9.2 المشغلات العلائقية     	   37](#المشغلات-العلائقية)  
[9.3 العمليات المنطقية     	   39](#العمليات-المنطقية)  
[9.4 مشغلات Bitwise     	   40](#مشغلات-bitwise)  
[9.5 مشغلات التعيين     	   43](#مشغلات-التعيين)  
[9.6 مشغلات متنوعة     	   45](#مشغلات-متنوعة)  
[9.7 أولوية المشغلات     	   46](#أولوية-المشغلات)  
[10 **صناعة القرار**](#صناعة-القرار)	  
[10.1 عبارة if     	   49](#عبارة-if)  
[10.2 عبارة if…else     	   50](#عبارة-if…else)  
[10.3 عبارة if...else if...else     	   52](#عبارة-if...else-if...else)  
[10.4 عبارات if المتداخلة     	   54](#عبارات-if-المتداخلة)  
[10.5 عبارة switch     	   56](#عبارة-switch)  
[10.6 عبارات switch المتداخلة     	   58](#عبارات-switch-المتداخلة)  
[10.7 المشغل ؟ \_ :     	   60](#المشغل-؟-_-:)  
[11 **الحلقات LOOPS**](#الحلقات-loops)	  
[11.1 حلقة while     	   61](#حلقة-while)  
[11.1.1 *البنية النحوية*     	   61](#البنية-النحوية)  
[11.2 حلقة for     	   63](#حلقة-for)  
[11.3 حلقة do...while     	   65](#حلقة-do...while)  
[11.4 الحلقات المتداخلة     	   67](#الحلقات-المتداخلة)  
[11.5 عبارات التحكم في الحلقة     	   70](#عبارات-التحكم-في-الحلقة)  
[11.6 عبارة break     	   70](#عبارة-break)  
[11.7 عبارة continue     	   72](#عبارة-continue)  
[11.8 عبارة goto     	   74](#عبارة-goto)  
[11.9 الحلقة اللانهائية     	   75](#الحلقة-اللانهائية)  
[12 **الدالة**](#الدالة)	  
[12.1  تعريف الدالة     	   77](#تعريف-الدالة)  
[12.2 إعلانات الدالة     	   78](#إعلانات-الدالة)  
[12.3 استدعاء دالة     	   79](#استدعاء-دالة)  
[12.4 حجج الدالة     	   80](#حجج-الدالة)  
[12.5 الاتصال حسب القيمة     	   81](#الاتصال-حسب-القيمة)  
[12.6 الاستدعاء بالإشارة     	   82](#الاستدعاء-بالإشارة)  
[13 **النطاق**](#النطاق)	  
[13.1 المتغيرات المحلية     	   85](#المتغيرات-المحلية)  
[13.2 المتغيرات العالمية     	   86](#المتغيرات-العالمية)  
[13.3 المعلمات الرسمية     	   87](#المعلمات-الرسمية)  
[13.4 تهيئة المتغيرات المحلية والعالمية     	   88](#تهيئة-المتغيرات-المحلية-والعالمية)  
[14 **المصفوفات**](#المصفوفات)	  
[14.1  إعلان المصفوفات     	   89](#إعلان-المصفوفات)  
[14.2 تهيئة المصفوفات     	   90](#تهيئة-المصفوفات)  
[14.3 الوصول إلى عناصر المصفوفة     	   90](#الوصول-إلى-عناصر-المصفوفة)  
[14.4 المصفوفات بالتفصيل     	   92](#المصفوفات-بالتفصيل)  
[14.4.1 *مصفوفات متعددة الأبعاد*     	   92](#مصفوفات-متعددة-الأبعاد)  
[14.4.2 *المصفوفات ثنائية الأبعاد*     	   92](#المصفوفات-ثنائية-الأبعاد)  
[14.4.3 *تهيئة المصفوفات ثنائية الأبعاد*     	   93](#تهيئة-المصفوفات-ثنائية-الأبعاد)  
[14.4.4 *الوصول إلى عناصر المصفوفة ثنائية الأبعاد*     	   94](#الوصول-إلى-عناصر-المصفوفة-ثنائية-الأبعاد)  
[14.4.5 *تمرير المصفوفات إلى الدوال*     	   95](#تمرير-المصفوفات-إلى-الدوال)  
[14.4.6 *إرجاع مصفوفة من دالة*     	   97](#إرجاع-مصفوفة-من-دالة)  
[14.4.7 *مؤشر إلى مصفوفة*     	   100](#مؤشر-إلى-مصفوفة)  
[15 **السلاسل**](#السلاسل)	  
[16 **المؤشرات**](#المؤشرات)	  
[16.1 إعلان المؤشر     	   105](#إعلان-المؤشر)  
[16.2 كيف تستخدم المؤشرات     	   106](#كيف-تستخدم-المؤشرات)  
[16.3 مؤشرات NULL     	   107](#مؤشرات-null)  
[16.4 المؤشرات بالتفصيل     	   108](#المؤشرات-بالتفصيل)  
[16.4.1 *حساب المؤشر*     	   109](#حساب-المؤشر)  
[16.4.2 *زيادة المؤشر*     	   109](#زيادة-المؤشر)  
[16.4.3 *تقليل قيمة المؤشر*     	   110](#تقليل-قيمة-المؤشر)  
[16.4.4 *مقارنات المؤشرات*     	   111](#مقارنات-المؤشرات)  
[16.4.5 *مجموعة من المؤشرات*     	   113](#مجموعة-من-المؤشرات)  
[16.4.6 *مؤشر إلى مؤشر*     	   115](#مؤشر-إلى-مؤشر)  
[16.4.7 *تمرير المؤشرات إلى الدوال*     	   117](#تمرير-المؤشرات-إلى-الدوال)  
[16.4.8 *إرجاع المؤشر من الدوال*     	   119](#إرجاع-المؤشر-من-الدوال)  
[17  **حقول البت Bit Fields**](#حقول-البت-bit-fields)	  
[18 **الهياكل**](#الهياكل)	  
[18.1 بنية الهيكل     	   122](#بنية-الهيكل)  
[18.2 الوصول إلى أعضاء الهيكل     	   123](#الوصول-إلى-أعضاء-الهيكل)  
[18.3 الهياكل كحجة دالة     	   124](#الهياكل-كحجة-دالة)  
[18.4 مؤشرات إلى الهياكل     	   126](#مؤشرات-إلى-الهياكل)  
[19 **الاتحاد**](#الاتحاد)	  
[19.1 تعريف الاتحاد     	   133](#تعريف-الاتحاد)  
[19.2 الوصول إلى أعضاء الاتحاد     	   135](#الوصول-إلى-أعضاء-الاتحاد)  
[20 **الكلمة الرئيسية TYPEDEF**](#الكلمة-الرئيسية-typedef)	  
[20.1 typedef مقابل \#define     	   139](#typedef-مقابل-#define)  
[21 **المدخلات والمخرجات**](#المدخلات-والمخرجات)	  
[21.1 الملفات القياسية     	   141](#الملفات-القياسية)  
[21.2 دالة ()getchar و ()putchar     	   141](#دالة-\(\)getchar-و-\(\)putchar)  
[21.3 الدالة gets() و puts()     	   142](#الدالة-gets\(\)-و-puts\(\))  
[21.4 دالة scanf() و printf()     	   143](#دالة-scanf\(\)-و-printf\(\))  
[22 **إدخال/إخراج الملف**](#إدخال/إخراج-الملف)	  
[22.1 فتح ملف     	   145](#فتح-ملف)  
[22.2 إغلاق ملف     	   146](#إغلاق-ملف)  
[22.3 كتابة ملف     	   146](#كتابة-ملف)  
[22.4 قراءة ملف     	   147](#قراءة-ملف)  
[22.5 إدخال وإخراج البيانات الثنائية     	   149](#إدخال-وإخراج-البيانات-الثنائية)  
[23 **المعالج المسبق**](#المعالج-المسبق)	  
[23.1 أمثلة     	   150](#أمثلة)  
[23.2 وحدات الماكرو المحددة مسبقًا     	   152](#وحدات-الماكرو-المحددة-مسبقًا)  
[23.3 مشغلات المعالج المسبق     	   153](#مشغلات-المعالج-المسبق)  
[23.3.1 *عامل استمرار الماكرو (\\)*     	   153](#عامل-استمرار-الماكرو-\(\\\))  
[23.3.2 *عامل تحويل السلسلة (\#)*     	   153](#عامل-تحويل-السلسلة-\(#\))  
[23.3.3 *عامل لصق الرمز (\#\#)*     	   154](#عامل-لصق-الرمز-\(##\))  
[23.3.4 *عامل Defined()*     	   155](#عامل-defined\(\))  
[23.4  وحدات الماكرو ذات المعلمات     	   155](#وحدات-الماكرو-ذات-المعلمات)  
[24 **ملف الرأس HEADER FILES**](#ملف-الرأس-header-files)	  
[24.1 التضمين Include     	   157](#التضمين-include)  
[24.2 عملية التضمين     	   158](#عملية-التضمين)  
[24.3 العناوين التي يتم عرضها مرة واحدة فقط     	   159](#العناوين-التي-يتم-عرضها-مرة-واحدة-فقط)  
[24.4 التضمين المحسوب     	   159](#التضمين-المحسوب)  
[25 **تحويل النوع TYPE CASTING**](#تحويل-النوع-type-casting)	  
[25.1 ترقية الأعداد الصحيحة     	   162](#ترقية-الأعداد-الصحيحة)  
[25.2  التحويل الحسابي المعتاد     	   162](#التحويل-الحسابي-المعتاد)  
[26 **معالجة الأخطاء**](#معالجة-الأخطاء)	  
[26.1 errno, perror(), و strerror()     	   164](#errno,-perror\(\),-و-strerror\(\))  
[26.2  أخطاء القسمة على صفر     	   165](#أخطاء-القسمة-على-صفر)  
[26.3 خروج البرنامج بقيمة     	   166](#خروج-البرنامج-بقيمة)  
[27 **التكرار**](#التكرار)	  
[27.1 أعداد العامل     	   168](#heading=h.xyx331bbps9n)  
[27.2 سلسلة فيبوناتشي     	   169](#heading=h.krwcufido9tv)  
[28 **دالة يمكنها قبول عدد متغير من المعلمات**](#دالة-يمكنها-قبول-عدد-متغير-من-المعلمات)	  
[29 **إدارة الذاكرة الديناميكية**](#إدارة-الذاكرة-الديناميكية)	  
[29.1 تمرير قيمة حجم أثناء تخصيص الذاكرة     	   174](#تمرير-قيمة-حجم-أثناء-تخصيص-الذاكرة)  
[29.2 تحرير كل الذاكرة المخصصة     	   176](#تحرير-كل-الذاكرة-المخصصة)  
[30 **تمرير القيم من سطر الأوامر إلى برامج C**](#تمرير-القيم-من-سطر-الأوامر-إلى-برامج-c)	

1. # **نظرة عامة**	 {#نظرة-عامة}

   1. ## **لماذا نستخدم C؟	**	 {#لماذا-نستخدم-c؟}

على الرغم من ظهور مئات لغات البرمجة الحديثة والأكثر سهولة، إلا أن لغة C (التي طُورت في السبعينيات) لا تزال حجر الزاوية في عالم الحاسوب.

نستخدم C لهذه الأسباب الجوهرية:

1. ### **الكفاءة والسرعة العالية (Speed and Efficiency)** {#الكفاءة-والسرعة-العالية-(speed-and-efficiency)}

لغة C هي لغة "منخفضة المستوى" (Low-level) نسبياً، مما يعني أنها قريبة جداً من لغة الآلة التي يفهمها المعالج.

* **التحسين** البرامج المكتوبة بـ C تعمل بسرعة فائقة وتستهلك قدراً ضئيلاً جداً من الذاكرة مقارنة بلغات مثل Python أو Java.

* **بدون تعقيدات** لا يوجد "جامع نفايات" (Garbage Collector) أو طبقات خفية تبطئ التنفيذ، مما يجعلك المتحكم الأول في موارد الجهاز.

  2. ### **التحكم المباشر في العتاد (Direct Hardware Access)** {#التحكم-المباشر-في-العتاد-(direct-hardware-access)}

تسمح C للمبرمجين بالتعامل المباشر مع الذاكرة وعناوين الأجهزة باستخدام **المؤشرات (Pointers)**.

* هذا يجعلها اللغة الأساسية لكتابة **تعريفات الأجهزة (Drivers)**، وهي البرمجيات التي تسمح لنظام التشغيل بالتحدث مع كرت الشاشة، أو الطابعة، أو لوحة المفاتيح.

  3. ### **الأنظمة المدمجة (Embedded Systems)** {#الأنظمة-المدمجة-(embedded-systems)}

هذا هو المجال الذي تسيطر فيه C بلا منازع. الأنظمة المدمجة هي أجهزة كمبيوتر صغيرة مخصصة لمهمة محددة وتوجد داخل أجهزة أخرى (مثل أنظمة السيارات، أجهزة التكييف، الغسالات، وأجهزة إنترنت الأشياء IoT).

* نظراً لمحدودية الذاكرة والمعالجة في هذه الأجهزة، تعتبر C الخيار الأمثل لأنها خفيفة وسريعة جداً.

  4. ### **"لغة اللغات" (The Mother of All Languages)** {#"لغة-اللغات"-(the-mother-of-all-languages)}

تعلم C يمنحك فهماً عميقاً لكيفية عمل الكمبيوتر من الداخل (إدارة الذاكرة، المكدس Stack، الكومة Heap).

* معظم اللغات الحديثة (C++, Java, C\#, Python, PHP) استعارت قواعدها النحوية (Syntax) من C.

* إذا تعلمت C، فإن الانتقال لأي لغة أخرى سيكون سهلاً جداً.

* **حقيقة مثيرة**: أشهر لغات البرمجة مثل Python والمترجمات الخاصة بها (Compilers) مكتوبة في الأصل باستخدام لغة C\!

  5. ### **قابلية النقل (Portability)** {#قابلية-النقل-(portability)}

شعار C هو "أكتب مرة واحدة، وجمّع في أي مكان" (Write once, compile anywhere). كود C القياسي يمكن تشغيله على أي نوع من المعالجات أو أنظمة التشغيل تقريباً مع تغييرات طفيفة جداً، مما يجعلها لغة عالمية.

| *المجال* |       *أمثلة واقعية* |
| ----- | ----- |
| أنظمة التشغيل | نواة Linux، نواة Windows، و macOS مكتوبة بشكل أساسي بـ C. |
| قواعد البيانات | أشهر قواعد البيانات مثل Oracle و MySQL و PostgreSQL مكتوبة بـ C. |
| الألعاب | المحركات الأساسية للألعاب تتطلب سرعة قصوى، لذا تُبنى غالباً بـ C أو C++. |
| إنترنت الأشياء **(IoT)** | أجهزة الاستشعار الذكية والأردوينو (Arduino). |

2. # **إعداد البيئة**	 {#إعداد-البيئة}

   1. ## **جربه عبر الإنترنت**	 {#جربه-عبر-الإنترنت}

[https://www.programiz.com/c-programming/online-compiler/](https://www.programiz.com/c-programming/online-compiler/)

3. # **هيكل البرنامج**	 {#هيكل-البرنامج}

   1. ##  **مرحبا بالعالم „Hello World“**  	 {#مرحبا-بالعالم-„hello-world“}

يتكون برنامج C بشكل أساسي من الأجزاء التالية:  
• أوامر المعالج المسبق  
• الوظائف  
• المتغيرات  
• العبارات والتعبيرات  
• التعليقات  
دعونا نلقي نظرة على كود بسيط من شأنه طباعة الكلمات "Hello World":

|    \#include \<stdio.h\>   \#include \<stdlib.h\>      int main()   {       /\* this is the simliest program in C \*/       printf("Hello world\!\\n");       return 0;   }  |
| :---- |

دعونا نلقي نظرة على الأجزاء المختلفة من البرنامج المذكور أعلاه:  
1\. السطر الأول من البرنامج**\<include \<stdio.h\#** هو أمر معالج مسبق، يخبر مُجمِّع **C** بتضمين ملف **stdio.h** قبل الانتقال إلى التجميع الفعلي.  
2\. السطر التالي**()** **int main** هو الدالة الرئيسية التي يبدأ عندها تنفيذ البرنامج.  
3\. سيتم تجاهل السطر التالي **/\*...\*/** بواسطة المُجمِّع وقد تم وضعه لإضافة تعليقات إضافية في البرنامج. لذا تسمى هذه الأسطر تعليقات في البرنامج.  
4\. السطر التالي**(...) printf**  هو دالة أخرى متوفرة في **C** تتسبب في عرض الرسالة **"\! Hello, World"** على الشاشة.  
5\. السطر التالي **return 0**; ينهي الدالة **()**  **main** ويعيد القيمة 0\.

2. ## **تجميع وتنفيذ برنامج C** {#تجميع-وتنفيذ-برنامج-c}

دعنا نرى كيفية حفظ الكود المصدر في ملف، وكيفية تجميعه وتشغيله. فيما يلي الخطوات البسيطة:  
1\. افتح محرر نصوص وأضف الكود المذكور أعلاه.  
2\. احفظ الملف باسم **hello.c**  
3\. افتح موجه الأوامر وانتقل إلى الدليل الذي قمت بحفظ الملف فيه.  
4\. اكتب **gcc hello.c** واضغط على **Enter** لتجميع الكود الخاص بك.  
5\. إذا لم تكن هناك أخطاء في الكود الخاص بك، فسينقلك موجه الأوامر إلى السطر التالي وسيولد ملفًا قابلاً للتنفيذ **a.out**.  
6\. الآن، اكتب **a.out** لتنفيذ برنامجك.  
7\. سترى الناتج **"Hello World"** مطبوعًا على الشاشة.

|  $ gcc hello.c $ ./a.out  Hello, World\!  |
| :---- |

تأكد من وجود مُجمِّع **gcc** في المسار الخاص بك وأنك تقوم بتشغيله في الدليل الذي يحتوي على ملف المصدر **hello.c**.

4. # **بناء الجملة الأساسي**	 {#بناء-الجملة-الأساسي}

لقد شاهدت البنية الأساسية لبرنامج **C**، لذا سيكون من السهل فهم اللبنات الأساسية الأخرى للغة البرمجة **C**.

1. ## **الرموز في لغة C**	 {#الرموز-في-لغة-c}

يتكون برنامج C من رموز مختلفة، والرمز هو إما كلمة رئيسية أو معرف أو ثابت أو حرف سلسلة أو رمز. على سبيل المثال، تتكون عبارة C التالية من خمسة رموز:

|  printf("Hello world\!\\n");  |
| :---- |

الرموز الفردية هي:

|  Printf ( "Hello world\!\\n" ) ;  |
| :---- |

2. ## **الفواصل المنقوطة**		 {#الفواصل-المنقوطة}

في برنامج C، تكون الفاصلة المنقوطة بمثابة نهاية جملة. أي أنه يجب إنهاء كل جملة فردية بفاصلة منقوطة. فهي تشير إلى نهاية كيان منطقي واحد.  
فيما يلي عبارتان مختلفتان:

|  printf("Hello world\!\\n"); return 0;  |
| :---- |

3. ## **تعليقات**		 {#تعليقات}

 التعليقات تشبه النص المساعد في برنامج C الخاص بك، ويتجاهلها المترجم. تبدأ بـ /\* وتنتهي بالأحرف \*/ كما هو موضح أدناه:

|   /\* my first program in C \*/  |
| :---- |

لا يمكنك الحصول على تعليقات داخل التعليقات ولا تظهر داخل سلسلة أو حرف حرفي.

4. ## **المعرفات**		 {#المعرفات}

معرف لغة C هو اسم يستخدم لتحديد متغير أو دالة أو أي عنصر آخر محدد بواسطة المستخدم. يبدأ المعرف بحرف من A إلى Z، أو من a إلى z، أو بعلامة سفلية "\_" متبوعة بصفر أو أكثر من الأحرف والعلامات السفلية والأرقام (من 0 إلى 9).  
لا تسمح لغة C بعلامات الترقيم مثل @ و$ و% داخل المعرفات. لغة C هي لغة برمجة حساسة لحالة الأحرف. وبالتالي، فإن Jasmina وjasmina هما معرفان مختلفان في لغة C. فيما يلي بعض الأمثلة على المعرفات المقبولة:

Obayda	

Lena	

jasmin	

TempName

my\_var	

\_\_temp\_\_		

retValue

5. ## **الكلمات الرئيسية**	 {#الكلمات-الرئيسية}

	تُظهر القائمة التالية الكلمات المحجوزة في لغة C. لا يجوز استخدام هذه الكلمات المحجوزة كثوابت أو متغيرات أو أي أسماء معرفات أخرى.

**auto**	 		  
**break**			  
**case**			  
**char**			  
**const**			  
**continue**			  
**default**			  
**do**			  
**double**	  
**else**	  
**enum**	  
**extern**  
**float**  
**for**  
**goto**  
**if**  
**int**  
**long**  
**register**  
**return**  
**short**  
**signed**  
**sizeof**  
**static**  
**struct**  
**switch**  
**typedef**  
**union**  
**unsigned**  
**void**  
**volatile**  
**while**  
**\_Packed**

6. ## **المسافة البيضاء في لغة C	**	 {#المسافة-البيضاء-في-لغة-c}

السطر الذي يحتوي على مسافات بيضاء فقط، ربما مع تعليق، يُعرف باسم السطر الفارغ، ويتجاهله مُجمِّع C تمامًا.  
المسافة البيضاء هو المصطلح المستخدم في C لوصف المسافات الفارغة وعلامات التبويب وأحرف السطر الجديد والتعليقات. تفصل المسافة البيضاء جزءًا من عبارة عن جزء آخر وتمكن المُجمِّع من تحديد مكان انتهاء عنصر في عبارة، مثل int، وبداية العنصر التالي. لذلك، في العبارة التالية:

|  int sum\_of\_integer;  |
| :---- |

يجب أن يكون هناك على الأقل حرف مسافة بيضاء (عادةً مسافة) بين int وsum\_of\_interger حتى يتمكن المترجم من التمييز بينهما. من ناحية أخرى، في البيان التالي:

|  Sum\_of\_integer \= 1 \+ 2 \+ 3 \+ 4 \+ 5 \+ 6 \+ 7 \+ 8 \+ 9;    // get the summe of the integer 0 till 9  |
| ----- |

لا توجد حاجة إلى وجود أحرف مسافة بيضاء بين sum\_of\_integer و=، أو بين \= و1، على الرغم من أنك حر في تضمين بعض هذه الأحرف إذا كنت ترغب في زيادة قابلية القراءة.

5. # **أنواع البيانات**		 {#أنواع-البيانات}

تشير أنواع البيانات في لغة C إلى نظام شامل يستخدم لإعلان المتغيرات أو الوظائف من أنواع مختلفة. يحدد نوع المتغير مقدار المساحة التي يشغلها في التخزين وكيفية تفسير نمط البت المخزن.

يمكن تصنيف الأنواع في لغة C على النحو التالي:  
• الأنواع الأساسية:  
◦ وهي أنواع حسابية وتصنف أيضًا إلى: (أ) أنواع الأعداد الصحيحة و(ب) أنواع الفاصلة العائمة.  
• الأنواع المعدودة:  
◦ وهي أيضًا أنواع حسابية وتستخدم لتحديد المتغيرات التي يمكنها فقط تعيين قيم عددية صحيحة منفصلة معينة في جميع أنحاء البرنامج.  
• النوع void:  
◦ يشير محدد النوع void إلى عدم توفر أي قيمة.  
• الأنواع المشتقة:  
◦ وهي تشمل (أ) أنواع المؤشرات، (ب) أنواع المصفوفة، (ج) أنواع البنية، (د) أنواع الاتحاد، و(هـ) أنواع الوظيفة.

يشار إلى أنواع المصفوفة وأنواع البنية بشكل جماعي باسم الأنواع المجمعة. يحدد نوع الدالة نوع قيمة الإرجاع الخاصة بالدالة. سنرى الأنواع الأساسية في القسم التالي، بينما سيتم تناول الأنواع الأخرى في الفصول القادمة.

1. ## **أنواع الأعداد الصحيحة**	 {#أنواع-الأعداد-الصحيحة}

يوفر الجدول التالي تفاصيل أنواع الأعداد الصحيحة القياسية مع أحجام تخزينها ونطاقات قيمتها:

| *Type* | *Storage size* | *Min. value* | *Max. value* |
| ----- | :---: | ----- | ----- |
| **char** | 1 byte | \-128 | 127 |
| **unsigned char** | 1 byte | 0 | 255 |
| **signed char** | 1 byte | \-128 | 127 |
| **int (int16)** | 2 bytes | \-32768 | 32767 |
| **int (int32)** | 4 bytes | \-2147483648 | 2147483647 |
| **unsigned int** | 2 bytes | 0 | 65535 |
| **unsigned int** | 4 bytes | 0 | 4294967295 |
| **short** | 2 bytes | \-32768 | 32767 |
| **unsigned short** | 2 bytes | 0 | 65535 |
| **long** | 4 bytes | \-2147483648 | 2147483647 |
| **unsigned long** | 4 bytes | 0 | 4294967295 |

للحصول على الحجم الدقيق لنوع أو متغير على منصة معينة، يمكنك استخدام عامل sizeof. تعطي التعبيرات sizeof(type) حجم تخزين الكائن أو النوع بالبايتات. فيما يلي مثال للحصول على حجم نوع int على أي جهاز:

|    \#include \<stdio.h\>    \#include \<limits.h\>      int main()   {       printf("Storage size of int : %d \\n", sizeof(int) );       return 0;   }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية على Linux:

| Storage size for int : 4 |
| :---- |

2. ## **أنواع النقطة العائمة Floating-Point**		 {#أنواع-النقطة-العائمة-floating-point}

يوفر الجدول التالي تفاصيل أنواع الفاصلة العائمة القياسية مع أحجام التخزين ونطاقات القيمة ودقتها:

| *Type* | *Storage size* | *Min. value* | *Max. value* | *Precision* |
| ----- | :---: | :---: | :---: | :---: |
| **float** | 4 byte | 1.2E-38 | 3.4E+38 | 6 decimal places |
| **double** | 8 byte | 2.3E-308 | 1.7E+308 | 15 decimal places |
| **long double** | 10 byte | 3.4E-4932 | 1.1E+4932 | 19 decimal places |

يحدد ملف الرأس float.h وحدات الماكرو التي تسمح لك باستخدام هذه القيم وتفاصيل أخرى حول التمثيل الثنائي للأرقام الحقيقية في برامجك. يطبع المثال التالي مساحة التخزين التي يشغلها نوع float وقيم نطاقه:

|     \#include \<stdio.h\>     \#include \<float.h\>        int main()    {        printf("Storage size for float : %d \\n", sizeof(float));        printf("Minimum float positive value: %E\\n", FLT\_MIN );        printf("Maximum float positive value: %E\\n", FLT\_MAX );        printf("Precision value: %d\\n", FLT\_DIG );           return 0;   }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية على Linux:

| Storage size for float : 4 Minimum float positive value:1.175494E-38  Maximum float positive value:3.402823E+38  Precision value: 6 |
| :---- |

3. ## **النوع void **	 {#النوع-void}

يحدد نوع void عدم توفر أي قيمة. ويُستخدم في ثلاثة أنواع من المواقف:  
1 ترجع الدالة كـ void  
توجد دوال مختلفة في لغة C لا ترجع أي قيمة أو يمكنك القول إنها ترجع void. ويكون نوع الإرجاع للدالة التي لا تحتوي على قيمة إرجاع هو void. على سبيل المثال، void func ( int stat )؛

2 وسيطات الدالة كـ void  
توجد دوال مختلفة في لغة C لا تقبل أي معلمة. ويمكن للدالة التي لا تحتوي على معلمة أن تقبل void. على سبيل المثال، int rand(void)؛

3 مؤشرات إلى void  
يمثل المؤشر من نوع void \* عنوان الكائن، ولكن ليس نوعه. على سبيل المثال، ترجع دالة تخصيص الذاكرة void \*malloc(size\_t size); مؤشرًا إلى void يمكن تحويله إلى أي نوع بيانات.

6. # **المتغيرات**		 {#المتغيرات}

المتغير ليس سوى اسم يُطلق على منطقة تخزين يمكن لبرامجنا التعامل معها. ولكل متغير في لغة C نوع محدد، يحدد حجم وتخطيط ذاكرة المتغير؛ ونطاق القيم التي يمكن تخزينها داخل تلك الذاكرة؛ ومجموعة العمليات التي يمكن تطبيقها على المتغير.  
يمكن أن يتكون اسم المتغير من أحرف وأرقام وعلامة الشرطة السفلية. ويجب أن يبدأ إما بحرف أو علامة شرطة سفلية. والأحرف الكبيرة والصغيرة مميزة لأن لغة C حساسة لحالة الأحرف. واستنادًا إلى الأنواع الأساسية الموضحة في الفصل السابق، ستكون هناك أنواع المتغيرات الأساسية التالية:

| Type | Description |
| :---- | ----- |
| **char** | عادةً ما يكون بايتًا واحدًا..(one byte). وهو نوع عدد صحيح int  |
| **int** | الحجم الطبيعي للعدد الصحيح للآلة. |
| **float** | قيمة النقطة العائمة ذات الدقة المفردة. |
| **double** | قيمة النقطة العائمة ذات الدقة المزدوجة. |
| **void** | يمثل غياب النوع. |

تسمح لغة البرمجة C أيضًا بتعريف أنواع أخرى مختلفة من المتغيرات، والتي سنغطيها في الفصول اللاحقة مثل التعداد، والمؤشر، والمصفوفة، والهيكل، والاتحاد، وما إلى ذلك. في هذا الفصل، دعنا ندرس فقط أنواع المتغيرات الأساسية.

1. ## **تعريف المتغير في لغة C**		 {#تعريف-المتغير-في-لغة-c}

يخبر تعريف المتغير المترجم بمكان وكمية التخزين التي يجب إنشاؤها للمتغير. يحدد تعريف المتغير نوع البيانات ويحتوي على قائمة بمتغير واحد أو أكثر من هذا النوع على النحو التالي:

| type variable\_list; |
| :---- |

هنا، يجب أن يكون النوع عبارة عن نوع بيانات C صالح بما في ذلك char، وw\_char، وint، وfloat، وdouble، وbool، أو أي كائن محدد من قبل المستخدم؛ وقد تتكون قائمة المتغيرات من اسم معرف واحد أو أكثر مفصولة بفواصل. يتم عرض بعض الإعلانات الصالحة هنا:

|    int    i, j, k;   char   ch;    float  div, f;    double d;  |
| :---- |

يعلن السطر int i, j, k؛ ويحدد المتغيرات i وj وk؛ والتي تعطي التعليمات للمترجم لإنشاء متغيرات باسم i وj وk من النوع int.  
يمكن تهيئة المتغيرات (تعيين قيمة أولية لها) في إعلانها. يتكون المبدئ من علامة مساوية متبوعة بتعبير ثابت على النحو التالي:

| type variable\_name \= value; |
| :---- |

بعض الأمثلة هي:

|  extern int d \= 3, f \= 5; // declaration of d and f.  int d \= 3, f \= 5;        // definition and initializing d and f  char a\_Char \= 'x';       // the variable a\_char has the value'x'    |
| :---- |

بالنسبة للتعريف بدون مُبدئ: يتم تهيئة المتغيرات ذات مدة التخزين الثابتة ضمناً بـ NULL (كل البايتات لها القيمة 0)؛ القيمة الأولية لجميع المتغيرات الأخرى غير محددة.

2. ## **إعلان المتغيرات في لغة C	**	 {#إعلان-المتغيرات-في-لغة-c}

يوفر إعلان المتغير ضمانًا للمترجم بوجود متغير بالنوع والاسم المحددين حتى يتمكن المترجم من المضي قدمًا في التجميع الإضافي دون الحاجة إلى التفاصيل الكاملة حول المتغير. يكون لإعلان المتغير معناه في وقت التجميع فقط، ويحتاج المترجم إلى إعلان المتغير الفعلي في وقت ربط البرنامج.  
يكون إعلان المتغير مفيدًا عندما تستخدم ملفات متعددة وتقوم بتعريف متغيرك في أحد الملفات التي ستكون متاحة في وقت ربط البرنامج. ستستخدم الكلمة الأساسية extern لإعلان متغير في أي مكان. على الرغم من أنه يمكنك إعلان متغير عدة مرات في برنامج C الخاص بك، إلا أنه لا يمكن تعريفه إلا مرة واحدة في ملف أو دالة أو كتلة من التعليمات البرمجية.

مثال  
جرب المثال التالي، حيث تم إعلان المتغيرات في الأعلى، ولكن تم تعريفها وتهيئتها داخل الدالة الرئيسية:

|   \#include \<stdio.h\>         // Variable declaration: extern int a, b;   extern int c; extern float f;      int main ()   {   /\* variable definition: \*/ int a, b;   int c; float f;      /\* actual initialization \*/   a \= 10;   b \= 20;         c \= a \+ b;   printf("value of c : %d \\n", c);         f \= 70.0/3.0;   printf("value of f : %f \\n", f);         return 0;   }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of c : 30 value of f : 23.333334 |
| :---- |

ينطبق نفس المفهوم على إعلان الوظيفة حيث تقدم اسم الوظيفة في وقت إعلانها ويمكن تقديم تعريفها الفعلي في أي مكان آخر. على سبيل المثال:

|   // function declaration    int func();   int main()   {     // function call      int i \= int func()   }   // function definition   int func()   {      return 0;   } |
| :---- |

3. ## **القيم L والقيم R في لغة C**	 {#القيم-l-والقيم-r-في-لغة-c}

يوجد نوعان من التعبيرات في لغة C:

• lvalue: التعبيرات التي تشير إلى موقع ذاكرة تسمى تعبيرات "lvalue". قد تظهر lvalue إما على الجانب الأيسر أو الأيمن من التعيين.  
• rvalue: يشير مصطلح rvalue إلى قيمة بيانات مخزنة في عنوان ما في الذاكرة. rvalue عبارة عن تعبير لا يمكن تعيين قيمة له، مما يعني أن rvalue قد تظهر على الجانب الأيمن ولكن ليس على الجانب الأيسر من التعيين.  
المتغيرات هي قيم lvalue وبالتالي قد تظهر على الجانب الأيسر من التعيين. الحروف الرقمية هي قيم rvalue وبالتالي قد لا يتم تعيينها ولا يمكن أن تظهر على الجانب الأيسر. ألق نظرة على العبارات الصحيحة وغير الصحيحة التالية:	

|  int g \= 20;   // valid statement  10 \= 20;      // invalid statement; would generate compile-time error  |
| :---- |

7. # **الثوابت والحرفيات**	 {#الثوابت-والحرفيات}

تشير الثوابت إلى قيم ثابتة لا يجوز للبرنامج تغييرها أثناء تنفيذه. وتسمى هذه القيم الثابتة أيضًا بالقيم الحرفية.  
يمكن أن تكون الثوابت من أي نوع بيانات أساسي مثل ثابت عدد صحيح أو ثابت عائم أو ثابت حرفي أو ثابت سلسلة. وهناك أيضًا ثوابت تعداد.  
يتم التعامل مع الثوابت تمامًا مثل المتغيرات العادية باستثناء أنه لا يمكن تعديل قيمها بعد تعريفها.

1. ## **حرفيات الاعداد الصحيحة Interger**	 {#حرفيات-الاعداد-الصحيحة-interger}

يمكن أن يكون الحرف الصحيح ثابتًا عشريًا أو ثمانيًا أو سداسي عشريًا. تحدد البادئة الأساس أو القاعدة: 0x أو 0X للسداسي عشر، و0 للثماني، ولا شيء للعشري.  
يمكن أن يكون للحرف الصحيح أيضًا لاحقة عبارة عن مزيج من U وL، للغير موقّع والطويل، على التوالي. يمكن أن تكون اللاحقة بأحرف كبيرة أو صغيرة ويمكن أن تكون بأي ترتيب.  
فيما يلي بعض الأمثلة على الحرف الصحيح:

| 1  212     /\* Legal \*/ 2  215u    /\* Legal \*/ 3  0xFeeL  /\* Legal \*/ 4  078     /\* Illegal: 8 is not an octal digit \*/ 5  032UU   /\* Illegal: cannot repeat a suffix \*/  |
| :---- |

فيما يلي أمثلة أخرى لأنواع مختلفة من الأحرف الصحيحة:

| 1  85      /\*  decimal \*/ 2  0213    /\*  octal \*/ 3  0x4b    /\*  hexadecimal \*/ 4  30      /\*  int \*/ 5  30u     /\*  unsigned int \*/ 6  30l     /\*  long \*/ 7  30ul    /\*  unsigned long \*  |
| :---- |

2. ## **الحرف ذو الفاصلة العائمة Floating-point**	 {#الحرف-ذو-الفاصلة-العائمة-floating-point}

يحتوي الحرف ذو الفاصلة العائمة على جزء صحيح ونقطة عشرية وجزء كسري وجزء أس. يمكنك تمثيل الحرف ذو الفاصلة العائمة إما في شكل عشري أو في شكل أسي.  
عند تمثيل الشكل العشري، يجب عليك تضمين النقطة العشرية أو الأس أو كليهما؛ وعند تمثيل الشكل الأسي، يجب عليك تضمين الجزء الصحيح أو الجزء الكسري أو كليهما. يتم تقديم الأس الموقّع بواسطة e أو E.  
فيما يلي بعض الأمثلة على الحرف ذو الفاصلة العائمة:

|   3.14159     /\* Legal \*/   314159E-5L  /\* Legal \*/   510E        /\* Illegal: incomplete exponent \*/   210f        /\* Illegal: no decimal or exponent \*/   .e55        /\* Illegal: missing integer or fraction \*/  |
| :---- |

3. ## **ثوابت الأحرف** {#ثوابت-الأحرف}

 Character Constantsيحتوي

…………

| *Escapeتسلسل الهروب* | *المَقصود* |
| :---: | ----- |
| \\\\ | \\ حرف |
| \\' |  'حرف |
| \\" |  "حرف |
| \\? | ?حرف |
| \\a | تنبيه أو جرس |
| \\b |  Backspaceمسافة للخلف |
| \\f | تغذية النموذج |
| \\n | سطر جديد |
| \\r | حرف إرجاع |
| \\t | علامة التبويب الأفقية |
| \\v | علامة التبويب العمودية |
| \\ooo | عدد ثماني من رقم واحد إلى ثلاثة أرقام |
| \\xhh | عدد سداسي عشري مكون من رقم واحد أو أكثر |

فيما يلي مثال لإظهار بعض أحرف تسلسل الهروب:

| 1  \#include \<stdio.h\> 2   3  int main() 4  { 5     printf("Hello\\tWorld\\n\\n"); 6   7     return 0; 8   9  } |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Hello	World   |
| :---- |

4. ## **String سلسلة حرفية**	 {#string-سلسلة-حرفية}

حروف السلسلة  
الحروف أو الثوابت السلسلة محاطة بعلامات اقتباس مزدوجة "". تحتوي السلسلة على أحرف تشبه حروف السلسلة: أحرف عادية، وتسلسلات إفلات، وأحرف عالمية.  
يمكنك تقسيم سطر طويل إلى أسطر متعددة باستخدام حروف السلسلة وفصلها باستخدام المسافات البيضاء.  
فيما يلي بعض الأمثلة على حروف السلسلة. كل الأشكال الثلاثة عبارة عن سلاسل متطابقة.

|   "hello, dear"      "hello, \\   dear"      "hello, " "d" "ear"  |
| :---- |

5. ## **تعريف الثوابت**	 {#تعريف-الثوابت}

 توجد طريقتان بسيطتان في لغة C لتحديد الثوابت:  
• استخدام المعالج المسبق \#define  
• استخدام الكلمة الأساسية const

1. ### **المعالج المسبق \#define**	 {#المعالج-المسبق-#define}

المعالج المسبق \#define  
فيما يلي النموذج لاستخدام المعالج المسبق \#define لتحديد ثابت:

| \#define identifier value  |
| :---- |

المثال التالي يوضح ذلك بالتفصيل:

|   \#include \<stdio.h\>      \#define LENGTH 10   \#define WIDTH 5    \#define NEWLINE '\\n'      int main()   {       int area;          area \= LENGTH \* WIDTH;       printf("value of area : %d", area);       printf("%c", NEWLINE);          return 0;   }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of area : 50 |
| :---- |

2. ### **المفتاح cosnt**	 {#المفتاح-cosnt}

يمكنك استخدام بادئة const لإعلان الثوابت بنوع معين على النحو التالي:

| const type variable \= value |
| :---- |

المثال التالي يوضح ذلك بالتفصيل:

|   \#include \<stdio.h\>      int main()   {       const int LENGTH;       const int WIDTH;       const char NEWLINE \= '\\n';       int area;              area \= LENGTH \* WIDTH;              printf("value of area : %d", area);       printf("%c", NEWLINE);              return 0;   }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of area : 50 |
| :---- |

لاحظ أن ممارسة البرمجة الجيدة هي تحديد الثوابت بالأحرف الكبيرة.	

8. #  **المشغلين Operators**	 {#المشغلين-operators}

المشغل هو رمز يخبر المترجم بأداء وظائف رياضية أو منطقية محددة. لغة C غنية بالمشغلات المضمنة وتوفر الأنواع التالية من المشغلات:

    • Arithmetic Operators

    • Relational Operators

    • Logical Operators

    • Bitwise Operators

    • Assignment Operators

    • Misc Operators

سننظر في هذا الفصل إلى الطريقة التي يعمل بها كل مشغل.

1. ## **العمليات الحسابية**		 {#العمليات-الحسابية}

العمليات الحسابية  
يوضح الجدول التالي جميع العمليات الحسابية التي تدعمها لغة C. افترض أن المتغير A يحتوي على 10 والمتغير B يحتوي على 20، إذن:

| Operator | Description | Example |
| :---- | :---- | :---- |
| \+ | Adds two operands. | A \+ B \= 30 |
| \- | Subtracts second operand from the first. | A \- B \= \-10 |
| \* | Multiplies both operands. | A \* B \= 200 |
| / | Divides numerator by de-numerator. | B / A \= 2 |
| % | Modulus Operator and remainder of after an integer division. | B % A \= 0 |
| \++ | Increment operator increases the integer value by one. | A++ \= 11 |
| \-- | Decrement operator decreases the integer value by one. | A-- \= 9 |

مثال  
جرب المثال التالي لفهم جميع العمليات الحسابية المتوفرة في لغة C:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int a \= 21;  6      int b \= 10;  7      int c ;  8    9      c \= a \+ b; 10      printf("Line 1 \- Value of c is %d\\n", c); 11      c \= a \- b; 12      printf("Line 2 \- Value of c is %d\\n", c); 13      c \= a \* b; 14      printf("Line 3 \- Value of c is %d\\n", c); 15      c \= a / b; 16      printf("Line 4 \- Value of c is %d\\n", c); 17      c \= a % b; 18      printf("Line 5 \- Value of c is %d\\n", c); 19      c \= a\++; 20      printf("Line 6 \- Value of c is %d\\n", c); 21      c \= a\--; 22      printf("Line 7 \- Value of c is %d\\n", c ); 23       24      return 0; 25  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Line 1 \- Value of c is 31 Line	2	\- Value	of	c	is	11 Line	3	\- Value	of	c	is	210 Line	4	\- Value	of	c	is	2 Line	5	\- Value	of	c	is	1 Line	6	\- Value	of	c	is	21 Line	7	\- Value	of	c	is	22 |
| :---- |

2. ## **المشغلات العلائقية**	 {#المشغلات-العلائقية}

المشغلات العلائقية  
يوضح الجدول التالي جميع المشغلات العلائقية التي يدعمها C. افترض أن المتغير A يحتوي على 10 والمتغير B يحتوي على 20، إذن:

| Operator | Description | Example |
| :---- | :---- | :---- |
| \== | Checks if the values of two operands are equal or not. If yes, then the condition becomes true. | (A \== B) is not true. |
| \!= | Checks if the values of two operands are equal or not. If the values are not equal, then the condition becomes true. | (A \!= B) is true. |
| \> | Checks if the value of left operand is greater than the value of right operand. If yes, then the condition becomes true. | (A \> B) is not true. |
| \< | Checks if the value of left operand is less than the value of right operand. If yes, then the condition becomes true. | (A \< B) is true. |
| \>= | Checks if the value of left operand is greater than or equal to the value of right operand. If yes, then the condition becomes true. | (A \>= B) is not true. |
| \<= | Checks if the value of left operand is less than or equal to the value of right operand. If yes, then the condition becomes true. | (A \<= B) is true. |

مثال  
جرب المثال التالي لفهم جميع عوامل العلاقات المتوفرة في لغة C:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int a \= 21;  6      int b \= 10;  7      int c ;  8    9      if( a \== b ) 10      { 11          printf("Line 1 \- a is equal to b\\n" ); 12   13      } 14      else 15      { 16          printf("Line    1   \-   a   is  not equal to b\\n" ); 17      } 18      if ( a \< b ) 19      { 20          printf("Line    2   \-   a   is  less than b\\n" ); 21      } 22      else 23      { 24          printf("Line    2   \-   a   is  not less than b\\n" ); 25      } 26      if ( a \> b ) 27      { 28          printf("Line    3   \-   a   is  greater than b\\n" ); 29      } 30      else 31      { 32          printf("Line 3 \- a is not greater than b\\n" ); 33      } 34      /\* Lets change value of a and b \*/ 35      a \= 5; 36      b \= 20; 37      if ( a \<= b ) 38      { 39          printf("Line 4 \- a is either less than or equal to b\\n" ); 40      } 41      if ( b \>= a ) 42      { 43          printf("Line 5 \- b is either greater than or equal to b\\n" ); 44      } 45  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Line 1 \- a is not equal to b Line 2 \- a is not less than b Line 3 \- a is greater than b Line 4 \- a is either less than or equal to b Line 5 \- b is either greater than or equal to b |
| :---- |

3. ## **العمليات المنطقية**			 {#العمليات-المنطقية}

يوضح الجدول التالي جميع العوامل المنطقية التي تدعمها لغة C. افترض أن المتغير A يحمل القيمة 1 والمتغير B يحمل القيمة 0، إذن:

| Operator | Description | Example |
| :---- | :---- | :---- |
| && | Called Logical AND operator. | operands are becomes true. Non-zero, then If the both the condition (A && B) is false. |
| || | Called Logical OR Operator.  | If any of the two operands is non-zero, then the condition (A || B) is true. |
| \! | Called Logical NOT Operator. | It is used to reverse the logical state of its operand. If a condition is true, then Logical NOT operator will make it false. \!(A && B) is true. |

مثال  
جرب المثال التالي لفهم جميع العوامل المنطقية المتوفرة في لغة C:

|  1  \#include \<stdio.h\>  2    3    4  main()  5  {  6      int a \= 5;  7      int b \= 20;  8      int c ;  9   10      if ( a && b ) 11      { 12          printf("Line 1 \- Condition is true\\n" ); 13      } 14       15      if ( a || b ) 16      { 17          printf("Line 2 \- Condition is true\\n" ); 18      } 19       20      /\* lets change the value of a and b \*/ 21      a \= 0; 22      b \= 10; 23       24      if ( a && b ) 25      { 26          printf("Line 3 \- Condition is true\\n" ); 27      } 28      else 29      { 30          printf("Line 3 \- Condition is not true\\n" ); 31      } 32      if ( \!(a && b) ) 33      { 34          printf("Line 4 \- Condition is true\\n" ); 35      } 36       37      return 0; 38  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Line 1 \- Condition is true Line 2 \- Condition is true Line 3 \- Condition is not true Line 4 \- Condition is true |
| :---- |

4. ## **مشغلات Bitwise** 	 {#مشغلات-bitwise}

مشغلات البتات  
تعمل مشغلات البتات على البتات وتنفذ عمليات بت بت.

 جدول الحقيقة لـ & و| و^ هو كما يلي:

p	q	p & q	p | q	p ^ q

0	0	0	0	0

0	1	0	1	1

1	1	1	1	0

1	0	0	1	1

افترض أن A \= 60 و B \= 13؛ في الصيغة الثنائية، سيكونان على النحو التالي:

A \= 0011 1100

B \= 0000 1101

A\&B \= 0000 1100

A|B \= 0011 1101

A^B \= 0011 0001

\~A \= 1100 0011

يسرد الجدول التالي مشغلات البتات التي يدعمها C. افترض أن المتغير "A" يحتوي على 60 والمتغير "B" يحتوي على 13، إذن:

Operator	Description			Example

&		Binary AND Operator 	copies a bit to the result if it exists in both operands.						(A & B) \= 12, i.e., 0000 1100

|		Binary OR Operator 		copies a bit if it exists in either operand.	

						(A | B) \= 61, i.e., 0011 1101

^		Binary XOR Operator 	copies the bit if it is set in one operand but not both.						(A ^ B) \= 49, i.e., 0011 0001

\~		Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.							(\~A ) \= \-61, i.e., 1100 0011 in 2's

complement form.

\<\<		Binary Left Shift Operator. 	The left operands value is moved left by the number of 						bits specified by the right operand.	

						A \<\< 2 \= 240, i.e., 1111 0000

\>\>		Binary Right Shift Operator. 	The left operands value is moved right by the number 						of bits specified by the right operand.	

						A \>\> 2 \= 15, i.e., 0000 1111

مثال  
جرب المثال التالي لفهم جميع مشغلات البتات المتاحة في لغة C:

|  1  \#include \<stdio.h\>  2    3    4  main()  5  {  6      unsigned int a \= 60;  7      unsigned int b \= 13;  8      int c \= 0;  9       10      c \= a & b;/\* 12= 0000 1100 \*/ 11      printf("Line    1   \- Value of c is %d\\n", c); 12       13      c \= a | b; /\* 61 \= 0011 1101 \*/ 14      printf("Line    2   \- Value of c is %d\\n", c); 15       16      c \= a ^ b; /\* 49 \= 0011 0001 \*/ 17      printf("Line    3   \- Value of c is %d\\n", c); 18       19      c \= \~a; /\*-61 \= 1100 0011 \*/ 20      printf("Line    4   \- Value of c is %d\\n", c); 21       22      c \= a \<\< 2;  /\* 240 \= 1111 0000 \*/ 23      printf("Line    5   \- Value of c is %d\\n", c); 24       25      c \= a \>\> 2; 26      printf("Line    6   \- Value of c is %d\\n", c); 27       28      return 0; 29  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Line	1	\- Value	of	c	is	12 Line	2	\- Value	of	c	is	61 Line	3	\- Value	of	c	is	49 Line	4	\- Value	of	c	is	\-61 Line	5	\- Value	of	c	is	240 Line	6	\- Value	of	c	is	15 |
| :---- |

5. ## **مشغلات التعيين**	 {#مشغلات-التعيين}

مشغلات التعيين  
توضح الجداول التالية مشغلات التعيين التي تدعمها لغة C:

Operator	Description				Example

\=		Simple assignment operator. 		Assigns values from right side operands to left 							side operand.	C \= A \+ B will assign the value 							of A \+ B to C

\+=		Add AND assignment operator. 	It adds the right operand to the left operand and 							assigns the result to the left operand.	C \+= A is 							equivalent to C \= C \+ A

\-=		Subtract AND assignment operator. 	It subtracts the right operand from the left 								operand and assigns the result to the left 								operand.	C \-= A is equivalent to C \= C \- A

\*=		Multiply AND assignment operator. 	It multiplies the right operand with the left 								operand and assigns the result to the left 								operand.	C \*= A is equivalent to C \= C \* A

/=		Divide AND assignment operator. 	It divides the left operand with the right operand 							and assigns the result to the left operand.								C /= A is equivalent to C \= C / A

%=		Modulus AND assignment operator. 	It takes modulus using two operands and assigns 							the result to the left operand.	C %= A is 								equivalent to C \= C % A

\<\<=		Left shift AND assignment operator.		C \<\<= 2 is same as C= C \<\< 2

\>\>=		Right shift AND assignment operator.	C \>\>= 2 is same as C= C \>\> 2

&=		Bitwise AND assignment operator.		C &= 2 is same as C= C & 2

^=		Bitwise exclusive operator.		OR and assignment	C ^= 2 is same as C= C ^ 2

|=		Bitwise inclusive operator.		OR and assignment	C |= 2 is same as C \= C | 2

مثال  
جرب المثال التالي لفهم جميع عوامل التعيين المتوفرة في لغة C:

|  1    2  \#include \<stdio.h\>  3    4    5  main()  6  {  7      unsigned int a \= 60;  8      int c \= 10;  9   10      printf("Line 1 \-   \= Operator Example, Value of c \= %d\\n", c); 11      c \+= a; 12      printf("Line 2 \-  \+= Operator Example, Value of c \= %d\\n", c); 13      c \-= a; 14      printf("Line 3 \-  \-= Operator Example, Value of c \= %d\\n", c); 15      c \*= a; 16      printf("Line 4 \-  \*= Operator Example, Value of c \= %d\\n", c); 17      c /= a; 18      printf("Line 5 \-  /= Operator Example, Value of c \= %d\\n", c ); 19      c \= 200; 20      c %= a; 21      printf("Line 6 \-  %%= Operator Example, Value of c \= %d\\n", c ); 22      c \<\<= 2; 23      printf("Line 7 \- \<\<= Operator Example, Value of c \= %d\\n", c ); 24      c \>\>= 2; 25      printf("Line 8 \- \>\>= Operator Example, Value of c \= %d\\n", c ); 26      c &= 2; 27      printf("Line 9 \-  &= Operator Example, Value of c \= %d\\n", c ); 28      c ^= 2; 29   30      return 0; 31  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Line	1	\- \=	Operator	Example,	Value	of	c	\=	21 Line	2	\- \+=	Operator	Example,	Value	of	c	\=	42 Line	3	\- \-=	Operator	Example,	Value	of	c	\=	21 Line	4	\- \*=	Operator	Example,	Value	of	c	\=	441 Line	5	\- /=	Operator	Example,	Value	of	c	\=	21 Line	6	\- %=	Operator	Example,	Value	of	c	\=	11 |
| :---- |

6. ## **مشغلات متنوعة**	 {#مشغلات-متنوعة}

مشغلات متنوعة ↦ sizeof & ternary  
بالإضافة إلى المشغلات التي تمت مناقشتها أعلاه، هناك عدد قليل من المشغلات المهمة الأخرى بما في ذلك sizeof و ? : والتي تدعمها لغة C.

Operator	Description				Example

sizeof()	Returns the size of a variable.	sizeof(a), where a is integer, will return 4\.

&		Returns the address of a variable.	\&a; returns the actual address of the variable.

\*		Pointer to a variable.			\*a;

? :		Conditional Expression.		If Condition is true ? then value 

							X : otherwise value Y

مثال  
حاول اتباع المثال التالي لفهم كافة المشغلات المتنوعة المتوفرة فيC:

|  1  \#include \<stdio.h\>  2    3    4  main()  5  {  6      int a \= 4;  7      short b;  8      double c;  9      int\* ptr; 10      /\* example of sizeof operator \*/ 11      printf("Line 1 \- Size of variable a \= %d\\n", sizeof(a) ); 12      printf("Line 2 \- Size of variable b \= %d\\n", sizeof(b) ); 13      printf("Line 3 \- Size of variable c= %d\\n", sizeof(c) ); 14   15      ptr \= &a; 16   17      printf("value of a is %d\\n", a); 18      printf("\*ptr is %d.\\n", \*ptr); 19   20      /\* example of ternary operator \*/ 21      a \= 10; 22      b \= (a \== 1) ? 20: 30; 23      printf( "Value of b is %d\\n", b ); 24   25      b \= (a \== 10) ? 20: 30; 26      printf( "Value of b is %d\\n", b ); 27  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of a	is	 4 \*ptr                 is           4		 Value of b	is	30 Value of b	is	20 |
| :---- |

7. ## **أولوية المشغلات**		 {#أولوية-المشغلات}

أولوية المشغلات في لغة C  
تحدد أولوية المشغلات تجميع المصطلحات في تعبير وتقرر كيفية تقييم التعبير. تتمتع بعض المشغلات بأولوية أعلى من غيرها؛ على سبيل المثال، يتمتع مشغل الضرب بأولوية أعلى من مشغل الجمع.  
على سبيل المثال، x \= 7 \+ 3 \* 2؛ هنا، يتم تعيين x على 13 وليس 20 لأن المشغل \* يتمتع بأولوية أعلى من \+، لذا يتم ضربه أولاً بـ 3\*2 ثم إضافته إلى 7\.

هنا، تظهر المشغلات ذات الأولوية الأعلى في أعلى الجدول، وتظهر تلك ذات الأولوية الأقل في الأسفل. داخل تعبير، سيتم تقييم المشغلات ذات الأولوية الأعلى أولاً.

Category		Operator				Associativity

Postfix			() \[\] \-\> . \++ \- \-				Left to right

Unary			\+ \- \! \~ \++ \- \- (type)\* & sizeof	Right to left

Multiplicative		\* / %					Left to right

Additive		\+ \-					Left to right

Shift			\<\< \>\>					Left to right

Relational		\< \<= \> \>=				Left to right

Equality		\== \!=					Left to right

Bitwise AND		&					Left to right

Bitwise XOR		^					Left to right

Bitwise OR		|					Left to right

Logical AND		&&					Left to right

Logical OR		||					Left to right

Conditional		?:					Right to left

Assignment		\= \+= \-= \*= /= %=\>\>= \<\<= &= ^= |=	Right to left

Comma		,					Left to right

Example

جرب المثال التالي لفهم أولوية المشغل في لغة C:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int a \= 20;  6      int b \= 10;  7      int c \= 15;  8      int d \= 5;  9      int e; 10      e \= (a \+ b) \* c / d; 11      printf("Value of (a \+ b) \* c / d is : %d\\n", e ); 12   13      return 0; 14  }  |
| :---- |

عند تجميع البرنامج المذكور أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of (a \+ b) \* c / d is : 90 Value of ((a \+ b) \* c) / d is : 90 Value of (a \+ b) \* (c / d) is : 90 Value of a \+ (b \* c) / d is : 50 |
| :---- |

9. # **فئات التخزين**	 {#فئات-التخزين}

تحدد فئة التخزين نطاق (الرؤية) ومدة حياة المتغيرات و/أو الوظائف داخل برنامج C. وهي تسبق النوع الذي تعدل عليه. لدينا أربع فئات تخزين مختلفة في برنامج C:

    • **auto**

    • **register**

    • **static**

    • **extern**

1. ## **فئة التخزين التلقائيauto**		 {#فئة-التخزين-التلقائيauto}

فئة التخزين التلقائي هي فئة التخزين الافتراضية لجميع المتغيرات المحلية.

|   {       int mount;       auto int month;   }  |
| :---- |

يحدد المثال أعلاه متغيرين ضمن نفس فئة التخزين. لا يمكن استخدام "auto" إلا داخل الوظائف، أي المتغيرات المحلية.

2. ## **فئة التخزينregister**		 {#فئة-التخزينregister}

فئة تخزين السجل  
تُستخدم فئة تخزين السجل لتحديد المتغيرات المحلية التي يجب تخزينها في سجل بدلاً من ذاكرة الوصول العشوائي. وهذا يعني أن المتغير له حجم أقصى يساوي حجم السجل (عادةً كلمة واحدة) ولا يمكن تطبيق عامل "&" الأحادي عليه (لأنه لا يحتوي على موقع ذاكرة).

|   {       register int miles;   }  |
| :---- |

يجب استخدام السجل فقط للمتغيرات التي تتطلب الوصول السريع مثل العدادات. يجب أيضًا ملاحظة أن تعريف "سجل" لا يعني أن المتغير سيتم تخزينه في سجل. هذا يعني أنه قد يتم تخزينه في سجل اعتمادًا على القيود المفروضة على الأجهزة والتنفيذ.

3. ## **فئة التخزين	static**	 {#فئة-التخزين-static}

تعطي فئة التخزين الثابتة تعليمات للمترجم بالحفاظ على متغير محلي موجود أثناء عمر البرنامج بدلاً من إنشائه وتدميره في كل مرة يدخل فيها ويخرج من النطاق. لذلك، فإن جعل المتغيرات المحلية ثابتة يسمح لها بالحفاظ على قيمها بين استدعاءات الوظيفة.  
يمكن أيضًا تطبيق المعدِّل الثابت على المتغيرات العالمية. عند القيام بذلك، فإنه يتسبب في تقييد نطاق هذا المتغير بالملف الذي تم إعلانه فيه.  
في برمجة C، عند استخدام الثابت على عضو بيانات فئة، فإنه يتسبب في مشاركة نسخة واحدة فقط من هذا العضو بواسطة جميع كائنات فئته.

|   \#include \<stdio.h\>      /\* function declaration \*/   void func(void);      static int count \= 5;      main()   {       while(count\--)       {           func();       }       return 0;   }      /\* function definition \*/    void func( void )   {       static int i \= 5;       i\++;       printf("i is %d and count is %d\\n", i, count);   }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| i is 6 and count is 4 i is 7 and count is 3 i is 8 and count is 2  i is 9 and count is 1 i is 10 and count is 0 |
| :---- |

4. ## **فئة التخزين	extern**	 {#فئة-التخزين-extern}

تُستخدم فئة التخزين الخارجية لتوفير مرجع لمتغير عالمي يمكن رؤيته من قِبل كافة ملفات البرنامج. عند استخدام "extern"، لا يمكن تهيئة المتغير، ومع ذلك، فإنه يشير إلى اسم المتغير في موقع تخزين تم تعريفه مسبقًا.  
عندما يكون لديك ملفات متعددة وتقوم بتعريف متغير أو دالة عالمية، والتي سيتم استخدامها أيضًا في ملفات أخرى، فسيتم استخدام extern في ملف آخر لتوفير مرجع للمتغير أو الدالة المحددة. وللتوضيح فقط، يتم استخدام extern لإعلان متغير عالمي أو دالة في ملف آخر.  
يتم استخدام المعدِّل الخارجي بشكل شائع عندما يكون هناك ملفان أو أكثر يتشاركان نفس المتغيرات العالمية أو الدوال كما هو موضح أدناه.  
الملف الأول: main.c

|   \#include \<stdio.h\>           int count;   extern void write\_extern();           main()   {       count \= 5;       write\_extern();   }  |
| :---- |

الملف الثاني: support.c

|   \#include \<stdio.h\>      extern int count;      void write\_extern(void)   {       printf("count is %d\\n", count);   }  |
| :---- |

هنا، يتم استخدام extern لإعلان count في الملف الثاني، بينما يوجد تعريفه في الملف الأول، main.c. الآن، قم بتجميع هذين الملفين على النحو التالي:

| $gcc main.c support.c |
| :---- |

سينتج البرنامج القابل للتنفيذ a.out. عندما يتم تنفيذ هذا البرنامج، فإنه ينتج النتيجة التالية:

| 5 |
| :---- |

10. # **صناعة القرار**		 {#صناعة-القرار}

تتطلب هياكل اتخاذ القرار أن يحدد المبرمج شرطًا واحدًا أو أكثر ليتم تقييمه أو اختباره بواسطة البرنامج، إلى جانب بيان أو بيانات ليتم تنفيذها إذا تم تحديد أن الشرط صحيح، وبشكل اختياري، بيانات أخرى ليتم تنفيذها إذا تم تحديد أن الشرط خاطئ.  
يظهر أدناه الشكل العام لهيكل اتخاذ القرار النموذجي الموجود في معظم لغات البرمجة:

تفترض لغة البرمجة C أي قيم غير صفرية وغير فارغة على أنها صحيحة، وإذا كانت صفرية أو فارغة، فإنها تفترض قيمة خاطئة.  
توفر لغة البرمجة C الأنواع التالية من بيانات اتخاذ القرار.

Statement		Description

if statement		An if statement consists of a boolean expression followed by one or more statements.

if...else statement	An	if	statement	can	be	followed	by	an optional else statement, which executes when the Boolean expression is false.

nested if statements	You can use one if or else if statement inside another if or else if statement(s).

switch statement	A switch statement allows a variable to be tested for equality against a list of values.

nested switch statements	You can use one switch statement inside another

switch statement(s).

1. ## **عبارة if**	 {#عبارة-if}

تتكون جملة **if** من تعبير منطقي يتبعه جملة واحدة أو أكثر.

نحو جملة **if** في لغة البرمجة **C** هو:

| 1  if(boolean\_expression) 2  { 3      /\* statement(s) will execute if the boolean expression is true \*/ 4  }  |
| :---- |

إذا تم تقييم التعبير المنطقي على أنه صحيح، فسيتم تنفيذ كتلة التعليمات البرمجية داخل عبارة "if". إذا تم تقييم التعبير المنطقي على أنه خطأ، فسيتم تنفيذ أول مجموعة من التعليمات البرمجية بعد نهاية عبارة "if" (بعد الأقواس المتعرجة المغلقة).  
تفترض لغة البرمجة C أي قيم غير صفرية وغير فارغة على أنها صحيحة وإذا كانت صفرية أو فارغة، فسيتم افتراضها على أنها قيمة خاطئة.

مثال

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      /\* local variable definition \*/   6      int a \= 10;  7    8      /\* check the boolean condition using if statement \*/   9      if( a \< 20 ) 10      { 11          /\* if condition is true then print the following \*/  12          printf("a is less than 20\\n" ); 13      } 14      printf("value of a is : %d\\n", a); 15   16   17      return 0; 18  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| a is less than 20; value of a is : 10 |
| :---- |

2. ## **عبارة	if…else**	 {#عبارة-if…else}

يمكن أن يتبع عبارة **if** عبارة **else** اختيارية، والتي يتم تنفيذها عندما يكون التعبير المنطقي خاطئًا.

النحو

نحو عبارة **if...else** في لغة البرمجة **C** هو:

| 1  if(boolean\_expression) 2  { 3      /\* statement(s) will execute if the boolean expression is true \*/ 4  } 5  else 6  { 7      /\* statement(s) will execute if the boolean expression is false \*/ 8  }  |
| :---- |

إذا تم تقييم التعبير المنطقي على أنه صحيح، فسيتم تنفيذ كتلة if، وإلا فسيتم تنفيذ كتلة else.  
تفترض لغة البرمجة C أي قيم غير صفرية وغير فارغة على أنها صحيحة، وإذا كانت صفرية أو فارغة، فسيتم افتراضها على أنها قيمة خاطئة.

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      int a \= 100;  8    9      /\* check the boolean condition \*/  10      if( a \< 20 ) 11      { 12          /\* if condition is true then print the following \*/  13          printf("a is less than 20\\n" ); 14      } 15      else 16      { 17          /\* if condition is false then print the following \*/  18          printf("a is not less than 20\\n" ); 19      } 20      printf("value of a is : %d\\n", a); 21   22   23      return 0; 24  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| a is not less than 20; value of a is : 100 |
| :---- |

3. ## **عبارة if...else if...else** {#عبارة-if...else-if...else}

يمكن أن تتبع جملة if جملة else if...else اختيارية، وهي مفيدة جدًا لاختبار شروط مختلفة باستخدام جملة if...else if واحدة.  
عند استخدام جمل if...else if...else، هناك بعض النقاط التي يجب وضعها في الاعتبار:  
• يمكن أن تحتوي جملة if على صفر أو جملة else واحدة ويجب أن تأتي بعد أي جملة else if.  
• يمكن أن تحتوي جملة if على صفر أو العديد من جمل else if ويجب أن تأتي قبل جملة else.

• بمجرد نجاح جملة else if، لن يتم اختبار أي من جمل else if أو else المتبقية.

النحو

النحو الخاص بعبارة if...else if...else في لغة البرمجة C هو:

| if(boolean\_expression 1\) {		 /\* Executes when the boolean	expression 1 is true \*/	 }		 else if( boolean\_expression 2\)		 {		 /\* Executes when the boolean	expression 2 is true \*/	 }		 else if( boolean\_expression 3\)		 {		 /\* Executes when the boolean	expression 3 is true \*/	 }		 else		 {		 /\* executes when the none of	the above condition is true	\*/ } |
| :---- |

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/  7      int a \= 100;  8    9      /\* check the boolean condition \*/ 10      if( a \== 10 ) 11      { 12          /\* if condition is true then print the following \*/ 13          printf("Value of a is 10\\n" ); 14      } 15      else if( a \== 20 ) 16      { 17          /\* if else if condition is true \*/ 18          printf("Value of a is 20\\n" ); 19      } 20      else if( a \== 30 ) 21      { 22          /\* if else if condition is true \*/ 23          printf("Value of a is 30\\n" ); 24      } 25      else 26      { 27          /\* if none of the conditions is true \*/ 28          printf("None of the values is matching\\n" ); 29      } 30      printf("Exact value of a is: %d\\n", a ); 31   32   33      return 0; 34  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| None of the values is matching Exact value of a is: 100 |
| :---- |

4. ## **عبارات if المتداخلة**		 {#عبارات-if-المتداخلة}

عبارات if المتداخلة  
من القانوني دائمًا في برمجة C تضمين عبارات if-else، مما يعني أنه يمكنك استخدام عبارة if أو else if داخل عبارة if أو else if أخرى.

النحو الخاص بعبارات if المتداخلة هو كما يلي:

| if( boolean\_expression 1\) { /\* Executes when the boolean expression 1 is true \*/ if(boolean\_expression 2\) { /\* Executes when the boolean expression 2 is true \*/ } } |
| :---- |

يمكنك تعشيش else if...else بنفس الطريقة التي تعشيش بها عبارات if.

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      int a \= 100;  8      int b \= 200;  9   10   11      /\* check the boolean condition \*/  12      if( a \== 100 ) 13      { 14          /\* if condition is true then check the following \*/  15          if( b \== 200 ) 16          { 17              /\* if condition is true then print the following \*/  18              printf("Value of a is 100 and b is 200\\n" ); 19          } 20      } 21      printf("Exact value of a is : %d\\n", a ); 22      printf("Exact value of b is : %d\\n", b ); 23   24      return 0; 25  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of a is 100 and b is 200 Exact value of a is : 100 Exact value of b is : 200 |
| :---- |

5. ## **عبارة switch 	**		 {#عبارة-switch}

تسمح عبارة switch باختبار متغير للتأكد من تساويه مع قائمة من القيم. تسمى كل قيمة case، ويتم فحص المتغير الذي يتم تشغيله لكل حالة switch.

البنية النحوية

بنية جملة switch في لغة البرمجة C هي كما يلي:

|  1  switch(expression)  2  {  3      case constant\-expression  4              statement(s);  5          break; /\* optional \*/  6      case constant\-expression  7              statement(s);  8          break; /\* optional \*/  9      /\* you can have any number of case statements \*/ 10      default : /\* Optional \*/ 11      statement(s); 12  }  |
| :---- |

تنطبق القواعد التالية على عبارة switch:  
• يجب أن يكون التعبير المستخدم في عبارة switch من النوع الصحيح أو المعدود، أو أن يكون من نوع فئة حيث تحتوي الفئة على دالة تحويل واحدة إلى نوع صحيح أو معدود.  
• يمكنك الحصول على أي عدد من عبارات case داخل switch. يتبع كل case القيمة المراد مقارنتها وعلامة نقطتين.  
• يجب أن يكون تعبير الثابت لـ case من نفس نوع البيانات مثل المتغير في switch، ويجب أن يكون ثابتًا أو حرفيًا.  
• عندما يكون المتغير الذي يتم تشغيله مساويًا لـ case، سيتم تنفيذ العبارات التالية لتلك الحالة حتى يتم الوصول إلى عبارة break.  
• عند الوصول إلى عبارة break، ينتهي switch، وينتقل تدفق التحكم إلى السطر التالي بعد عبارة switch.

• لا تحتاج كل حالة إلى احتواء break. إذا لم يظهر break، فسوف ينتقل تدفق التحكم إلى الحالات اللاحقة حتى يتم الوصول إلى break.  
• يمكن أن تحتوي عبارة switch على حالة افتراضية اختيارية، والتي يجب أن تظهر في نهاية switch. يمكن استخدام الحالة الافتراضية لأداء مهمة عندما لا تكون أي من الحالات صحيحة. لا يلزم وجود فاصل في الحالة الافتراضية.

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      char grade \= 'B';  8    9      switch(grade) 10      { 11      case 'A' : 12          printf("Excellent\!\\n" ); 13          break; 14      case 'B' : 15      case 'C' : 16          printf("Well done\\n" ); 17          break; 18      case 'D' : 19          printf("You passed\\n" ); 20          break; 21      case 'F' : 22          printf("Better try again\\n" ); 23          break; 24      default : 25          printf("Invalid grade\\n" ); 26      } 27      printf("Your grade is %c\\n", grade ); 28   29      return 0; 30  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Well done Your grade is B |
| :---- |

6. ## **عبارات switch المتداخلة**		 {#عبارات-switch-المتداخلة}

من الممكن أن يكون هناك تبديل كجزء من تسلسل عبارات التبديل الخارجي. حتى لو كانت ثوابت الحالة للمفتاح الداخلي والخارجي تحتوي على قيم مشتركة، فلن تنشأ أي تعارضات.

النحو

النحو الخاص بعبارات التبديل المتداخلة هو كما يلي:

|  1  switch(ch1)  2  {  3  case 'A':  4      printf("This A is part of outer switch" );  5      switch(ch2)  6      {  7      case 'A':  8          printf("This A is part of inner switch" );  9          break; 10      case 'B': /\* case code \*/ 11      } 12      break; 13  case 'B': /\* case code \*/ 14  }  |
| :---- |

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      int a \= 100;  8      int b \= 200;  9   10   11      switch(a) 12      { 13      case 100: 14          printf("This is part of outer switch\\n", a ); 15          switch(b) 16          { 17          case 200: 18              printf("This is part of inner switch\\n", a ); 19          } 20      } 21      printf("Exact value of a is : %d\\n", a ); 22      printf("Exact value of b is : %d\\n", b ); 23   24      return 0; 25  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| This is part of outer switch This is part of inner switch Exact value of a is : 100 Exact value of b is : 200 |
| :---- |

7. ## **المشغل ؟ \_ :** 	 {#المشغل-؟-_-:}

لقد تناولنا المشغل الشرطي ؟ : في الفصل السابق والذي يمكن استخدامه لاستبدال عبارات if...else. وهو يأخذ الشكل العام التالي:

| Exp1 ? Exp2 : Exp3; |
| :---- |

حيث Exp1 وExp2 ​​وExp3 عبارة عن تعبيرات. لاحظ استخدام ومكان النقطتين.  
يتم تحديد قيمة تعبير ? على النحو التالي:  
1\. يتم تقييم Exp1. إذا كانت صحيحة، فسيتم تقييم Exp2 وتصبح قيمة تعبير ? بالكامل.  
2\. إذا كانت Exp1 خاطئة، فسيتم تقييم Exp3 وتصبح قيمتها قيمة التعبير.

11. # **الحلقات LOOPS**	 	 {#الحلقات-loops}

قد تواجه مواقف تتطلب تنفيذ كتلة من التعليمات البرمجية عدة مرات. بشكل عام، يتم تنفيذ العبارات بشكل متسلسل: يتم تنفيذ العبارة الأولى في الدالة أولاً، ثم الثانية، وهكذا.  
توفر لغات البرمجة هياكل تحكم مختلفة تسمح بمسارات تنفيذ أكثر تعقيدًا.  
تسمح لنا عبارة الحلقة بتنفيذ عبارة أو مجموعة من العبارات عدة مرات. فيما يلي الشكل العام لعبارة الحلقة في معظم لغات البرمجة:

توفر لغة البرمجة C الأنواع التالية من الحلقات للتعامل مع متطلبات الحلقات.

Loop Type		Description

while loop		Repeats a statement or group of statements while a given condition is true. 

			It tests the condition before executing the loop body.

for loop		Executes a sequence of statements multiple times and abbreviates the code 			that manages the loop variable.

do...while loop	It is more like a while statement, except that it tests the condition at 

			the end of the loop body.

nested loops		You can use one or more loops inside any other while, for, or do..while loop.

1. ## **حلقة while**		 {#حلقة-while}

حلقة while  
تنفذ حلقة while في برمجة C عبارة مستهدفة بشكل متكرر طالما أن الشرط المعطى صحيح.

1. ### **البنية النحوية** {#البنية-النحوية}

بنية حلقة while في برمجة C هي:

| while(condition) { statement(s); } |
| :---- |

هنا، قد تكون العبارة (العبارات) عبارة واحدة أو مجموعة من العبارات. قد يكون الشرط عبارة عن أي تعبير، وتكون القيمة true أي قيمة غير صفرية. تتكرر الحلقة أثناء كون الشرط صحيحًا.  
عندما يصبح الشرط خاطئًا، تنتقل عناصر التحكم في البرنامج إلى السطر الذي يلي الحلقة مباشرةً.

هنا، النقطة الأساسية التي يجب ملاحظتها هي أن حلقة while قد لا يتم تنفيذها على الإطلاق. عندما يتم اختبار الشرط وتكون النتيجة خاطئة، سيتم تخطي نص الحلقة وسيتم تنفيذ أول جملة بعد حلقة while.

مثال

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/  7      int a \= 10;  8    9      /\* while loop execution \*/ 10      while( a \< 20 ) 11      { 12          printf("value of a: %d\\n", a); 13          a\++; 14      } 15      return 0; 16  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 |
| :---- |

 

 

 

 

2. ## **حلقة for**	 {#حلقة-for}

حلقة for  
حلقة for هي بنية تحكم في التكرار تسمح لك بكتابة حلقة بكفاءة تحتاج إلى تنفيذها لعدد معين من المرات.

البنية النحوية  
بنية حلقة for في لغة البرمجة C هي:

| for ( init; condition; increment ) { statement(s); } |
| :---- |

فيما يلي تدفق التحكم في حلقة "for":  
1\. يتم تنفيذ خطوة التهيئة أولاً، ومرة ​​واحدة فقط. تتيح لك هذه الخطوة إعلان أي متغيرات تحكم في الحلقة وتهيئتها. لست ملزمًا بوضع عبارة هنا، طالما ظهرت فاصلة منقوطة.  
2\. بعد ذلك، يتم تقييم الشرط. إذا كان صحيحًا، يتم تنفيذ نص الحلقة. إذا كان خاطئًا، لا يتم تنفيذ نص الحلقة وينتقل تدفق التحكم إلى العبارة التالية بعد حلقة "for".  
3\. بعد تنفيذ نص حلقة "for"، يقفز تدفق التحكم مرة أخرى إلى عبارة الزيادة. تتيح لك هذه العبارة تحديث أي متغيرات تحكم في الحلقة. يمكن ترك هذه العبارة فارغة، طالما ظهرت فاصلة منقوطة بعد الشرط.

4\. يتم الآن تقييم الشرط مرة أخرى. إذا كان صحيحًا، يتم تنفيذ الحلقة وتتكرر العملية (نص الحلقة، ثم خطوة الزيادة، ثم الشرط مرة أخرى). بعد أن يصبح الشرط خاطئًا، تنتهي حلقة "for".

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* for loop execution \*/  7      for( int a \= 10; a \< 20; a \= a \+ 1 )  8      {  9          printf("value of a: %d\\n", a); 10      } 11   12      return 0; 13  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 |
| :---- |

3. ## **حلقة do...while**	 {#حلقة-do...while}

حلقة do...while  
على عكس حلقات for وwhile، التي تختبر شرط الحلقة في أعلى الحلقة، تتحقق حلقة do...while في برمجة C من شرطها في أسفل الحلقة.  
حلقة do...while تشبه حلقة while، باستثناء حقيقة أنها مضمونة للتنفيذ مرة واحدة على الأقل.

البنية النحوية  
بنية حلقة do...while في لغة برمجة C هي:

| do { statement(s); }while( condition ); |
| :---- |

لاحظ أن التعبير الشرطي يظهر في نهاية الحلقة، لذا يتم تنفيذ العبارة (العبارات) في الحلقة مرة واحدة قبل اختبار الشرط.

إذا كان الشرط صحيحًا، يقفز تدفق التحكم مرة أخرى إلى do، ويتم تنفيذ العبارة (العبارات) في الحلقة مرة أخرى. تتكرر هذه العملية حتى يصبح الشرط المحدد خاطئًا.

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      int a \= 10;  8    9      /\* do loop execution \*/  10      do 11      { 12          printf("value of a: %d\\n", a); 13          a \= a \+ 1; 14      } 15      while( a \< 20 ); 16   17      return 0; 18  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 value of a: 16 value of a: 17 value of a: 18 value of a: 19 |
| :---- |

4. ## **الحلقات المتداخلة**	 {#الحلقات-المتداخلة}

الحلقات المتداخلة  
تسمح برمجة C باستخدام حلقة داخل حلقة أخرى. يوضح القسم التالي بعض الأمثلة لتوضيح المفهوم.

النحو  
النحو الخاص بجملة الحلقة المتداخلة في C هو كما يلي:

| for ( init; condition; increment ) { for ( init; condition; increment ) { statement(s); } statement(s); } |
| :---- |

تكون صيغة جملة حلقة while المتداخلة في لغة البرمجة C على النحو التالي:

| while(condition) { while(condition) { statement(s); } statement(s); } |
| :---- |

تكون صيغة جملة حلقة do...while المتداخلة في لغة البرمجة C على النحو التالي:

| do { statement(s); do { statement(s); }while( condition );  }while( condition ); |
| :---- |

ملاحظة أخيرة حول تعشيش الحلقات هي أنه يمكنك وضع أي نوع من الحلقات داخل أي نوع آخر من الحلقات. على سبيل المثال، يمكن أن تكون حلقة "for" داخل حلقة "while" أو العكس.

مثال  
يستخدم البرنامج التالي حلقة "for" متداخلة للعثور على الأعداد الأولية من 2 إلى 100:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      /\* local variable definition \*/  6      int i, j;  7    8      for(i\=2; i\<100; i\++)  9      { 10          for(j\=2; j \<= (i/j); j\++) 11              if(\!(i%j)) 12                  break; 13          if(j \> (i/j)) 14              printf("%d is prime\\n", i); 15      } 16      return 0; 17  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| 2	is	prime 3	is	prime 5	is	prime 7	is	prime 11	is	prime 13	is	prime 17	is	prime 19	is	prime 23	is	prime 29	is	prime 31	is	prime 37	is	prime 41	is	prime 43	is	prime 47	is	prime 53	is	prime 59	is	prime 61	is	prime 67	is	prime 71	is	prime 73	is	prime 79	is	prime 83	is	prime 89	is	prime 97	is	prime |
| :---- |

5. ## **عبارات التحكم في الحلقة**	 {#عبارات-التحكم-في-الحلقة}

عبارات التحكم في الحلقة  
تغير عبارات التحكم في الحلقة التنفيذ من تسلسله الطبيعي. عندما يخرج التنفيذ من نطاق، يتم تدمير جميع الكائنات التلقائية التي تم إنشاؤها في هذا النطاق.  
تدعم لغة C عبارات التحكم التالية.

Control Statement		Description

break statement		Terminates the loop or switch statement and transfers execution to 

				the statement immediately following the loop or switch.

continue statement		Causes the loop to skip the remainder of its body and immediately 				retest its condition prior to reiterating.

goto statement 		Transfers control to the labeled statement.

6. ## **عبارة break**	 {#عبارة-break}

عبارة break  
تستخدم عبارة break في برمجة C في الاستخدامين التاليين:  
• عند مواجهة عبارة break داخل حلقة، يتم إنهاء الحلقة على الفور ويستأنف التحكم في البرنامج عند العبارة التالية بعد الحلقة.  
• يمكن استخدامها لإنهاء حالة في عبارة switch (المذكورة في الفصل التالي).

إذا كنت تستخدم حلقات متداخلة، فإن عبارة break ستوقف تنفيذ الحلقة الداخلية وتبدأ في تنفيذ السطر التالي من التعليمات البرمجية بعد الكتلة.

البنية النحوية  
بنية عبارة break في C هي كما يلي:

| break; |
| :---- |

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/   7      int a \= 10;  8    9      /\* while loop execution \*/  10      while( a \< 20 ) 11      { 12          printf("value of a: %d\\n", a); 13          a\++; 14          if( a \> 15) 15          { 16              /\* terminate the loop using break statement \*/  17              break; 18          } 19      } 20      return 0; 21  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 15 |
| :---- |

7. ## **عبارة continue**	 {#عبارة-continue}

عبارة continue  
تعمل عبارة continue في برمجة C إلى حد ما مثل عبارة break. فبدلاً من فرض الإنهاء، فإنها تجبر التكرار التالي للحلقة على الحدوث، وتتخطى أي كود بينهما.  
بالنسبة لحلقة for، تتسبب عبارة continue في تنفيذ أجزاء الاختبار الشرطي والزيادة في الحلقة. بالنسبة لحلقات while وdo...while، تتسبب عبارة continue في تمرير عنصر التحكم في البرنامج إلى الاختبارات الشرطية.

البنية النحوية  
بنية عبارة continue في C هي كما يلي:

| continue; |
| :---- |

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      /\* local variable definition \*/   6      int a \= 10;  7    8      /\* do loop execution \*/   9      do 10      { 11          if( a \== 15) 12          { 13              /\* skip the iteration \*/ a \= a \+ 1; 14              continue; 15          } 16          printf("value of a: %d\\n", a); 17          a\++; 18   19      } 20      while( a \< 20 ); 21   22      return 0; 23  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 16 value of a: 17 value of a: 18 value of a: 19 |
| :---- |

8. ## **عبارة goto**	 {#عبارة-goto}

عبارة goto  
تتيح عبارة goto في برمجة C الانتقال غير المشروط من "goto" إلى عبارة مُسمّاة في نفس الوظيفة.  
ملاحظة: لا يُنصح بشدة باستخدام عبارة goto في أي لغة برمجة لأنها تجعل من الصعب تتبع تدفق التحكم في البرنامج، مما يجعل البرنامج صعب الفهم وصعب التعديل. يمكن إعادة كتابة أي برنامج يستخدم عبارة goto لتجنبها.

النحو  
النحو الخاص بعبارة goto في لغة C هو كما يلي:

| goto label; .. . label: statement; |
| :---- |

يمكن أن يكون الملصق هنا أي نص عادي باستثناء كلمة رئيسية في لغة C ويمكن تعيينه في أي مكان في برنامج C أعلى أو أسفل العبارة goto.

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* local variable definition \*/  7      int a \= 10;  8    9      /\* do loop execution \*/ 10  LOOP: 11      do 12      { 13          if( a \== 15) 14          { 15              /\* skip the iteration \*/  16              a \= a \+ 1; 17              goto LOOP; 18          } 19          printf("value of a: %d\\n", a); 20          a\++; 21      } 22      while( a \< 20 ); 23   24      return 0; 25  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| value of a: 10 value of a: 11 value of a: 12 value of a: 13 value of a: 14 value of a: 16 value of a: 17 value of a: 18 value of a: 19 |
| :---- |

9. ## **الحلقة اللانهائية**	 {#الحلقة-اللانهائية}

الحلقة اللانهائية  
تتحول الحلقة إلى حلقة لا نهائية إذا لم يصبح الشرط خاطئًا أبدًا. تُستخدم حلقة for تقليديًا لهذا الغرض. نظرًا لعدم الحاجة إلى أي من التعبيرات الثلاثة التي تشكل حلقة "for"، يمكنك إنشاء حلقة لا نهائية عن طريق ترك التعبير الشرطي فارغًا.

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5    6      for( ; ; )  7      {  8          printf("This loop will run forever.\\n");  9      } 10   11      return 0; 12  }  |
| :---- |

عندما يكون التعبير الشرطي غائبًا، يُفترض أنه صحيح. قد يكون لديك تعبير تهيئة وزيادة، لكن مبرمجي C يستخدمون عادةً بنية for(;;) للإشارة إلى حلقة لا نهائية.  
ملاحظة: يمكنك إنهاء حلقة لا نهائية بالضغط على مفتاحي Ctrl \+ C.

12. # **الدالة**		 {#الدالة}

الوظيفة عبارة عن مجموعة من العبارات التي تؤدي معًا مهمة. يحتوي كل برنامج C على وظيفة واحدة على الأقل، وهي main()، ويمكن لجميع البرامج الأكثر بساطة تعريف وظائف إضافية.  
يمكنك تقسيم الكود الخاص بك إلى وظائف منفصلة. كيفية تقسيم الكود الخاص بك بين وظائف مختلفة متروك لك، ولكن من المنطقي أن يكون التقسيم بحيث تؤدي كل وظيفة مهمة محددة.  
يخبر إعلان الوظيفة المترجم باسم الوظيفة ونوع الإرجاع والمعلمات. يوفر تعريف الوظيفة النص الفعلي للوظيفة.  
توفر مكتبة C القياسية العديد من الوظائف المضمنة التي يمكن لبرنامجك استدعاؤها. على سبيل المثال، strcat() لربط سلسلتين، وmemcpy() لنسخ موقع ذاكرة إلى موقع آخر، والعديد من الوظائف الأخرى.  
يمكن أيضًا الإشارة إلى الوظيفة كطريقة أو روتين فرعي أو إجراء، وما إلى ذلك.

1. ##  **تعريف الدالة**	 {#تعريف-الدالة}

 تعريف الدالة  
الشكل العام لتعريف الدالة في لغة البرمجة C هو كما يلي:

| return\_type function\_name( parameter list ) { body of the function } |
| :---- |

يتألف تعريف الدالة في برمجة C من رأس الدالة وجسم الدالة. وفيما يلي جميع أجزاء الدالة:  
• نوع الإرجاع: قد تعيد الدالة قيمة. return\_type هو نوع البيانات للقيمة التي تعيدها الدالة. تقوم بعض الدوال بإجراء العمليات المطلوبة دون إرجاع قيمة. في هذه الحالة، return\_type هي الكلمة الأساسية void.  
• اسم الدالة: هذا هو الاسم الفعلي للدالة. يشكل اسم الدالة وقائمة المعلمات معًا توقيع الدالة.  
• المعلمات: المعلمة تشبه العنصر النائب. عند استدعاء الدالة، تمرر قيمة إلى المعلمة. يشار إلى هذه القيمة بالمعلمة الفعلية أو الوسيطة. تشير قائمة المعلمات إلى نوع وترتيب وعدد معلمات الدالة. المعلمات اختيارية؛ أي أن الدالة قد لا تحتوي على معلمات.

• جسم الدالة: يحتوي جسم الدالة على مجموعة من العبارات التي تحدد ما تفعله الدالة.

مثال  
فيما يلي الكود المصدر لدالة تسمى max(). تأخذ هذه الوظيفة معاملين num1 وnum2 وترجع القيمة القصوى بينهما:

|  1  /\* function returning the max between two numbers \*/   2  int max(int num1, int num2)  3  {  4      /\* local variable declaration \*/   5      int result;  6    7      if (num1 \> num2)   8          result \= num1;  9      else 10          result \= num2; 11   12      return result; 13  }  |
| :---- |

2. ## **إعلانات الدالة**		 {#إعلانات-الدالة}

إعلانات الوظائف  
يخبر إعلان الوظيفة المترجم باسم الوظيفة وكيفية استدعاء الوظيفة. يمكن تعريف نص الوظيفة الفعلي بشكل منفصل.  
يتكون إعلان الوظيفة من الأجزاء التالية:

| return\_type function\_name( parameter list ); |
| :---- |

بالنسبة للدالة max() المحددة أعلاه، يكون إعلان الدالة على النحو التالي:

| int max(int num1, int num2); |
| :---- |

أسماء المعلمات ليست مهمة في إعلان الوظيفة، فقط نوعها مطلوب، وبالتالي فإن ما يلي أيضًا إعلان صالح:

| int max(int, int); |
| :---- |

يلزم إعلان الوظيفة عند تعريف وظيفة في ملف مصدر واحد واستدعاء تلك الوظيفة في ملف آخر. في هذه الحالة، يجب إعلان الوظيفة في أعلى الملف الذي يستدعي الوظيفة.

3. ## **استدعاء دالة**		 {#استدعاء-دالة}

استدعاء دالة  
أثناء إنشاء دالة C، فإنك تقدم تعريفًا لما يجب أن تفعله الدالة. لاستخدام دالة، يجب عليك استدعاء تلك الدالة لأداء المهمة المحددة.  
عندما يستدعي برنامج دالة، يتم نقل عنصر التحكم في البرنامج إلى الدالة المستدعاة. تؤدي الدالة المستدعاة مهمة محددة وعندما يتم تنفيذ عبارة الإرجاع الخاصة بها أو عند الوصول إلى قوس الإغلاق الذي ينتهي بالدالة، فإنها تعيد عنصر التحكم في البرنامج إلى البرنامج الرئيسي.  
لاستدعاء دالة، ما عليك سوى تمرير المعلمات المطلوبة مع اسم الدالة، وإذا أعادت الدالة قيمة، فيمكنك تخزين القيمة المسترجعة. على سبيل المثال:

|  1  \#include \<stdio.h\>  2    3  /\* function declaration \*/   4  int max(int num1, int num2);  5    6  int main ()  7  {  8      /\* local variable definition \*/   9      int a \= 100; 10      int b \= 200; 11      int ret; 12   13      /\* calling a function to get max value \*/  14      ret \= max(a, b); 15      printf( "Max value is : %d\\n", ret ); 16   17      return 0; 18  } 19   20  /\* function returning the max between two numbers \*/  21  int max(int num1, int num2) 22  { 23      /\* local variable declaration \*/  24      int result; 25   26      if (num1 \> num2)  27          result \= num1; 28      else 29          result \= num2; 30   31      return result; 32  }  |
| :---- |

لقد احتفظنا بـ max() مع main() وقمنا بتجميع الكود المصدر. أثناء تشغيل الملف القابل للتنفيذ النهائي، فإنه سينتج النتيجة التالية:

| Max value is : 200 |
| :---- |

4. ## **حجج الدالة**	 {#حجج-الدالة}

حجج الدالة  
إذا كانت الدالة ستستخدم حججًا، فيجب عليها إعلان متغيرات تقبل قيم الحجج. تسمى هذه المتغيرات بالمعلمات الرسمية للدالة.  
تتصرف المعلمات الرسمية مثل المتغيرات المحلية الأخرى داخل الدالة ويتم إنشاؤها عند الدخول إلى الدالة وتدميرها عند الخروج.  
أثناء استدعاء الدالة، هناك طريقتان يمكن من خلالهما تمرير الحجج إلى الدالة:

Call Type		Description

Call by value		This method copies the actual value of an argument into the formal parameter 			of the function. In this case, changes made to the parameter inside the 				function have no effect on the argument.

Call by reference	This method copies the address of an argument into the formal parameter. 			Inside the function, the address is used to access the actual argument used in 			the call. This means that changes made to the parameter affect the argument.

5. ## **الاتصال حسب القيمة**		 {#الاتصال-حسب-القيمة}

الاتصال حسب القيمة	

إن طريقة الاستدعاء بالقيمة لتمرير الوسائط إلى دالة ما تنسخ القيمة الفعلية لوسيط ما إلى المعلمة الرسمية للدالة. في هذه الحالة، لا تؤثر التغييرات التي يتم إجراؤها على المعلمة داخل الدالة على الوسيطة.  
بشكل افتراضي، تستخدم لغة البرمجة C طريقة الاستدعاء بالقيمة لتمرير الوسائط. بشكل عام، يعني هذا أن الكود داخل الدالة لا يمكنه تغيير الوسائط المستخدمة لاستدعاء الدالة. ضع في اعتبارك تعريف الدالة swap() على النحو التالي.

|  1  /\* function definition to swap the values \*/  2  void swap(int x, int y)  3  {  4      int temp;  5    6      temp \= x; /\* save the value of x \*/  7      x \= y;  8      y \= temp; /\* put temp into y \*/  9      return; 10  }  |
| :---- |

الآن، دعونا نستدعي الدالة swap() عن طريق تمرير القيم الفعلية كما في المثال التالي:

|  1  \#include \<stdio.h\>  2    3  /\* function declaration \*/   4  void swap(int x, int y);  5    6  int main ()  7  {  8      /\* local variable definition \*/   9      int a \= 100; 10      int b \= 200; 11   12   13      printf("Before swap, value of a : %d\\n", a ); 14      printf("Before swap, value of b : %d\\n", b ); 15       16      /\* calling a function to swap the values \*/  17      swap(a, b); 18   19      printf("After swap, value of a : %d\\n", a ); 20      printf("After swap, value of b : %d\\n", b ); 21   22      return 0; 23  }  |
| :---- |

دعونا نضع الكود أعلاه في ملف C واحد، ونقوم بتجميعه وتنفيذه، وسوف ينتج النتيجة التالية:

| Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :100 After swap, value of b :200 |
| :---- |

ويظهر أنه لا يوجد أي تغييرات في القيم، على الرغم من أنها قد تم تغييرها داخل الدالة.

6. ## **الاستدعاء بالإشارة**		 {#الاستدعاء-بالإشارة}

الاستدعاء بالإشارة  
إن طريقة الاستدعاء بالإشارة لتمرير الوسائط إلى دالة ما تنسخ عنوان الوسيطة في المعلمة الرسمية. داخل الدالة، يتم استخدام العنوان للوصول إلى الوسيطة الفعلية المستخدمة في الاستدعاء. وهذا يعني أن التغييرات التي تم إجراؤها على المعلمة تؤثر على الوسيطة المرسلة.  
لتمرير قيمة بالإشارة، يتم تمرير مؤشرات الوسيطة إلى الدوال تمامًا مثل أي قيمة أخرى. وبالتالي، تحتاج إلى إعلان معلمات الدالة كأنواع مؤشرات كما في الدالة swap() التالية، والتي تتبادل قيم متغيري الأعداد الصحيحة المشار إليهما، من خلال وسيطاتهما.

|  1  /\* function definition to swap the values \*/  2  void swap(int \*x, int \*y)  3  {  4      int temp;  5      temp \= \*x;  6      \*x \= \*y;  7      \*y \= temp;  8      return;  9  }  |
| :---- |

دعونا الآن نستدعي الدالة swap() عن طريق تمرير القيم حسب المرجع كما في المثال التالي:

|  1  \#include \<stdio.h\>  2    3  /\* function declaration \*/   4  void swap(int \*x, int \*y);  5    6  int main ()  7  {  8      /\* local variable definition \*/   9      int a \= 100; 10      int b \= 200; 11   12      printf("Before swap, value of a : %d\\n", a ); 13      printf("Before swap, value of b : %d\\n", b ); 14   15      /\* calling a function to swap the values. 16          â€¢ \&a indicates pointer to a i.e. address of variable a and 17          â€¢ \&b indicates pointer to b i.e. address of variable b. 18      \*/ 19      swap(&a, &b); 20   21      printf("After swap, value of a : %d\\n", a ); 22      printf("After swap, value of b : %d\\n", b ); 23   24      return 0; 25  }  |
| :---- |

دعونا نضع الكود أعلاه في ملف C واحد، ونقوم بتجميعه وتنفيذه، لإنتاج النتيجة التالية:

| Before swap, value of a :100 Before swap, value of b :200 After swap, value of a :200 After swap, value of b :100 |
| :---- |

يُظهِر هذا أن التغيير انعكس خارج الدالة أيضًا، على عكس الاستدعاء بالقيمة حيث لا تنعكس التغييرات خارج الدالة.  
بشكل افتراضي، تستخدم لغة C الاستدعاء بالقيمة لتمرير الوسائط. بشكل عام، يعني هذا أن الكود داخل الدالة لا يمكنه تغيير الوسائط المستخدمة لاستدعاء الدالة.

13. # **النطاق**	 {#النطاق}

النطاق في أي برمجة هو منطقة من البرنامج حيث يمكن لمتغير محدد أن يتواجد ولا يمكن الوصول إليه خارج هذا المتغير. هناك ثلاثة أماكن يمكن فيها إعلان المتغيرات في لغة البرمجة C:  
• داخل دالة أو كتلة تسمى المتغيرات المحلية،  
• خارج جميع الدوال تسمى المتغيرات العالمية.  
• في تعريف معلمات الدالة تسمى  
المعلمات الرسمية.  
دعونا نفهم ما هي المتغيرات المحلية والعالمية والمعلمات الرسمية.

1. ## **المتغيرات المحلية**	 {#المتغيرات-المحلية}

 المتغيرات التي يتم إعلانها داخل دالة أو كتلة تسمى متغيرات محلية. لا يمكن استخدامها إلا بواسطة العبارات الموجودة داخل تلك الدالة أو كتلة التعليمات البرمجية. لا تُعرَف المتغيرات المحلية للوظائف خارج دالة خاصة بها. يوضح المثال التالي كيفية استخدام المتغيرات المحلية. هنا تكون جميع المتغيرات a وb وc محلية للدالة main().

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      /\* local variable declaration \*/   6      int a, b;  7      int c;  8    9      /\* actual initialization \*/ 10      a \= 10; 11      b \= 20; 12       13      c \= a \+ b; 14   15      printf ("value of a \= %d, b \= %d and c \= %d\\n", a, b, c); 16   17      return 0; 18  }  |
| :---- |

2. ## **المتغيرات العالمية**		 {#المتغيرات-العالمية}

المتغيرات العالمية  
يتم تعريف المتغيرات العالمية خارج الدالة، وعادةً ما تكون أعلى البرنامج. تحتفظ المتغيرات العالمية بقيمها طوال عمر البرنامج ويمكن الوصول إليها داخل أي من الدوال المحددة للبرنامج.  
يمكن الوصول إلى متغير عالمي بواسطة أي دالة. أي أن المتغير العالمي متاح للاستخدام في جميع أنحاء البرنامج بعد إعلانه. يوضح البرنامج التالي كيفية استخدام المتغيرات العالمية في البرنامج.

|  1  \#include \<stdio.h\>  2    3    4  /\* global variable declaration \*/   5  int g;  6    7  int main ()  8  {  9      /\* local variable declaration \*/  10      int a, b; 11   12      /\* actual initialization \*/ 13      a \= 10; 14      b \= 20; 15      g \= a \+ b; 16   17      printf ("value of a \= %d, b \= %d and g \= %d\\n", a, b, g); 18   19      return 0; 20  }  |
| :---- |

يمكن أن يكون للبرنامج نفس الاسم للمتغيرات المحلية والعالمية ولكن قيمة المتغير المحلي داخل الدالة ستحظى بالأولوية. فيما يلي مثال:

|  1  \#include \<stdio.h\>  2    3  /\* global variable declaration \*/   4  int g \= 20;  5    6  int main ()  7  {  8      /\* local variable declaration \*/   9      int g \= 10; 10   11      printf ("value of g \= %d\\n", g); 12   13      return 0; 14  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of g \= 10 |
| :---- |

3. ## **المعلمات الرسمية**	 {#المعلمات-الرسمية}

المعلمات الرسمية  
يتم التعامل مع المعلمات الرسمية كمتغيرات محلية داخل الدالة ولها الأولوية على المتغيرات العالمية. فيما يلي مثال:

|  1  \#include \<stdio.h\>  2    3  /\* global variable declaration \*/  4  int a \= 20;  5    6  int main ()  7  {  8      /\* local variable declaration in main function \*/  9      int a \= 10; 10      int b \= 20; 11      int c \= 0; 12   13      printf ("value of a in main() \= %d\\n", a); 14   15      c \= sum( a, b); 16   17      printf ("value of c in main() \= %d\\n", c); 18   19      return 0; 20  } 21   22  /\* function to add two integers \*/ 23  int sum(int a, int b) 24  { 25      printf ("value of a in sum() \= %d\\n", a); 26      printf ("value of b in sum() \= %d\\n", b); 27   28      return a \+ b; 29  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| value of a in main() \= 10 value of a in sum() \= 10 value of b in sum() \= 20 value of c in main() \= 30 |
| :---- |

4. ## **تهيئة المتغيرات المحلية والعالمية**	 {#تهيئة-المتغيرات-المحلية-والعالمية}

تهيئة المتغيرات المحلية والعالمية  
عند تعريف متغير محلي، لا يتم تهيئته بواسطة النظام، بل يجب عليك تهيئته بنفسك. يتم تهيئة المتغيرات العالمية تلقائيًا بواسطة النظام عند تعريفها، على النحو التالي:

| Data Type | Initial Default Value |
| :---- | :---- |
| *int* | 0 |
| *char* | '\\0' |
| *float* | 0 |
| *double* | 0 |
| *pointer* | NULL |

من الممارسات البرمجية الجيدة تهيئة المتغيرات بشكل صحيح، وإلا فقد ينتج برنامجك نتائج غير متوقعة، لأن المتغيرات غير المهيأة ستأخذ بعض قيم القمامة المتوفرة بالفعل في موقع الذاكرة الخاصة بها.

14. # **المصفوفات**	 {#المصفوفات}

المصفوفات هي نوع من هياكل البيانات التي يمكنها تخزين مجموعة متسلسلة ذات حجم ثابت من العناصر من نفس النوع. تُستخدم المصفوفة لتخزين مجموعة من البيانات، ولكن غالبًا ما يكون من المفيد التفكير في المصفوفة كمجموعة من المتغيرات من نفس النوع.  
بدلاً من إعلان متغيرات فردية، مثل number0 وnumber1 و... وnumber99، يمكنك إعلان متغير مصفوفة واحد مثل numbers واستخدام numbers\[0\] وnumbers\[1\] و... وnumbers\[99\] لتمثيل المتغيرات الفردية. يتم الوصول إلى عنصر معين في المصفوفة بواسطة فهرس.  
تتكون جميع المصفوفات من مواقع ذاكرة متجاورة. يتوافق العنوان الأدنى مع العنصر الأول والعنوان الأعلى مع العنصر الأخير.

| Numbers\[0\] | Numbers\[1\] | Numbers\[2\] | Numbers\[3\] | Numbers\[4\] | ... |
| :---- | :---- | :---- | :---- | :---- | :---- |

1. ##  **إعلان المصفوفات**	 {#إعلان-المصفوفات}

 إعلان المصفوفات  
لإعلان مصفوفة في لغة C، يحدد المبرمج نوع العناصر وعدد العناصر المطلوبة للمصفوفة على النحو التالي:

| type arrayName \[ arraySize \]; |
| :---- |

يُطلق على هذا اسم مصفوفة أحادية البعد. يجب أن يكون حجم المصفوفة ثابتًا صحيحًا أكبر من الصفر ويمكن أن يكون النوع أي نوع بيانات C صالح. على سبيل المثال، لإعلان مصفوفة مكونة من 10 عناصر تسمى balance من النوع double، استخدم هذا البيان:

| double balance\[10\]; |
| :---- |

هنا، التوازن عبارة عن مجموعة متغيرات تكفي لاستيعاب ما يصل إلى 10 أرقام مزدوجة.

2. ## **تهيئة المصفوفات**		 {#تهيئة-المصفوفات}

تهيئة المصفوفات  
يمكنك تهيئة المصفوفة في لغة C إما واحدة تلو الأخرى أو باستخدام عبارة واحدة على النحو التالي:

| double balance\[5\] \= {1000.0, 2.0, 3.4, 7.0, 50.0}; |
| :---- |

لا يمكن أن يكون عدد القيم بين الأقواس { } أكبر من عدد العناصر التي نعلن عنها للمصفوفة بين الأقواس المربعة \[ \].  
إذا قمت بحذف حجم المصفوفة، فسيتم إنشاء مصفوفة كبيرة بما يكفي لاستيعاب التهيئة. لذلك، إذا كتبت:

| double balance\[\] \= {1000.0, 2.0, 3.4, 7.0, 50.0}; |
| :---- |

ستقوم بإنشاء نفس المصفوفة تمامًا كما فعلت في المثال السابق. فيما يلي مثال لتعيين عنصر واحد من المصفوفة:

| balance\[4\] \= 50.0; |
| :---- |

يحدد البيان أعلاه العنصر الخامس في المصفوفة بقيمة 50.0. تحتوي جميع المصفوفات على 0 كمؤشر للعنصر الأول فيها والذي يُسمى أيضًا المؤشر الأساسي وسيكون المؤشر الأخير للمصفوفة هو الحجم الإجمالي للمصفوفة ناقص 1\. يظهر أدناه التمثيل التصويري للمصفوفة التي ناقشناها أعلاه:

|  | 0 | 1 | 2 | 3 | 4 |
| :---- | :---- | :---- | :---- | :---- | :---- |
| balance | 1000.0 | 2.0 | 3.4 | 7.0 | 50.0 |

3. ## **الوصول إلى عناصر المصفوفة**	 {#الوصول-إلى-عناصر-المصفوفة}

الوصول إلى عناصر المصفوفة  
يمكن الوصول إلى عنصر ما عن طريق فهرسة اسم المصفوفة. ويتم ذلك عن طريق وضع فهرس العنصر بين قوسين مربعين بعد اسم المصفوفة. على سبيل المثال:

| double salary \= balance\[9\]; |
| :---- |

ستأخذ العبارة أعلاه العنصر العاشر من المصفوفة وتعين القيمة لمتغير الراتب. يوضح المثال التالي كيفية استخدام المفاهيم الثلاثة المذكورة أعلاه وهي الإعلان والتعيين والوصول إلى المصفوفات:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      int n\[ 10 \]; /\* n is an array of 10 integers \*/   6      int i,j;  7      /\* initialize elements of array n to 0 \*/  8      for ( i \= 0; i \< 10; i\++ )  9      { 10          n\[ i \] \= i \+ 100; 11      } 12   13      /\* output each array element's value \*/  14      for (j \= 0; j \< 10; j\++ ) 15      { 16          printf("Element\[%d\] \= %d\\n", j, n\[j\] ); 17      } 18   19      return 0; 20  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Element\[0\]	\=	100 Element\[1\]	\=	101 Element\[2\]	\=	102 Element\[3\]	\=	103 Element\[4\]	\=	104 Element\[5\]	\=	105 Element\[6\]	\=	106 Element\[7\]	\=	107 Element\[8\]	\=	108 Element\[9\]	\=	109 |
| :---- |

4. ## **المصفوفات بالتفصيل**	 {#المصفوفات-بالتفصيل}

 المصفوفات بالتفصيل  
المصفوفات مهمة للغة C ويجب أن تحتاج إلى مزيد من الاهتمام. يجب أن تكون المفاهيم المهمة التالية المتعلقة بالمصفوفات واضحة لمبرمج C:

| Concept | Description |
| :---- | :---- |
| Multidimensional arrays | C supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array. |
| Passing arrays to functions | You can pass to the function a pointer to an array by specifying the array's name without an index. |
| Return array from a functio | C allows a function to return an array. |
| Pointer to an array | You can generate a pointer to the first element of an array by simply specifying the array name, without any index. |

1. ### **مصفوفات متعددة الأبعاد**	 {#مصفوفات-متعددة-الأبعاد}

تسمح لغة البرمجة C بإنشاء مصفوفات متعددة الأبعاد. فيما يلي الشكل العام لإعلان مصفوفة متعددة الأبعاد:

| type name\[size1\]\[size2\]...\[sizeN\]; |
| :---- |

على سبيل المثال، يؤدي الإعلان التالي إلى إنشاء مصفوفة عددية صحيحة ثلاثية الأبعاد:

| int threedim\[5\]\[10\]\[4\]; |
| :---- |

2. ### **المصفوفات ثنائية الأبعاد**	 {#المصفوفات-ثنائية-الأبعاد}

المصفوفات ثنائية الأبعاد  
أبسط أشكال المصفوفات متعددة الأبعاد هي المصفوفة ثنائية الأبعاد. المصفوفة ثنائية الأبعاد هي في الأساس قائمة من المصفوفات أحادية البعد. لإعلان مصفوفة عددية صحيحة ثنائية الأبعاد بحجم \[x\]\[y\]، يجب أن تكتب شيئًا على النحو التالي:

| type arrayName \[ x \]\[ y \]; |
| :---- |

حيث يمكن أن يكون النوع أي نوع بيانات صالح بلغة C، وسيكون arrayName معرفًا صالحًا بلغة C. يمكن اعتبار المصفوفة ثنائية الأبعاد جدولاً يحتوي على عدد x من الصفوف وعدد y من الأعمدة. يمكن عرض المصفوفة ثنائية الأبعاد a، التي تحتوي على ثلاثة صفوف وأربعة أعمدة على النحو التالي:

|  | Column 0 | Column 1 | Column 2 | Column 3 |
| :---- | :---- | :---- | :---- | :---- |
| Row 0 | a\[0\]\[0\] | a\[0\]\[1\] | a\[0\]\[2\] | a\[0\]\[3\] |
| Row 1 | a\[1\]\[0\] | a\[1\]\[1\] | a\[1\]\[2\] | a\[1\]\[3\] |
| Row 2 | a\[2\]\[0\] | a\[2\]\[1\] | a\[2\]\[2\] | a\[2\]\[3\] |

وبالتالي، يتم تحديد كل عنصر في المصفوفة a من خلال اسم عنصر من النموذج a\[ i\]\[j\]، حيث 'a' هو اسم المصفوفة، و'i' و'j' هما الرمزان السفليان اللذان يحددان بشكل فريد كل عنصر في 'a'.

3. ### **تهيئة المصفوفات ثنائية الأبعاد**	 {#تهيئة-المصفوفات-ثنائية-الأبعاد}

تهيئة المصفوفات ثنائية الأبعاد  
يمكن تهيئة المصفوفات متعددة الأبعاد من خلال تحديد قيم بين قوسين لكل صف. فيما يلي مصفوفة بها 3 صفوف وكل صف يحتوي على 4 أعمدة.

| int a\[3\]\[4\] \= { {0, 1, 2, 3} , {4, 5, 6, 7} , {8, 9, 10, 11} }; |
| :---- |

الأقواس المتداخلة، التي تشير إلى الصف المقصود، اختيارية. التهيئة التالية تعادل المثال السابق:

| int a\[3\]\[4\] \= {0,1,2,3,4,5,6,7,8,9,10,11}; |
| :---- |

4. ### **الوصول إلى عناصر المصفوفة ثنائية الأبعاد**	 {#الوصول-إلى-عناصر-المصفوفة-ثنائية-الأبعاد}

الوصول إلى عناصر المصفوفة ثنائية الأبعاد  
يمكن الوصول إلى عنصر في مصفوفة ثنائية الأبعاد باستخدام الفهارس السفلية، أي فهرس الصف وفهرس العمود للمصفوفة. على سبيل المثال:

| int val \= a\[2\]\[3\]; |
| :---- |

ستأخذ العبارة أعلاه العنصر الرابع من الصف الثالث من المصفوفة. يمكنك التحقق من ذلك في الشكل أعلاه. دعنا نتحقق من البرنامج التالي حيث استخدمنا حلقة متداخلة للتعامل مع مصفوفة ثنائية الأبعاد:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      /\* an array with 5 rows and 2 columns\*/  6      int a\[5\]\[2\] \= { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};  7      int i, j;  8    9      /\* output each array element's value \*/  10      for ( i \= 0; i \< 5; i\++ ) 11      { 12          for ( j \= 0; j \< 2; j\++ ) 13          { 14              printf("a\[%d\]\[%d\] \= %d\\n", i,j, a\[i\]\[j\] ); 15          } 16      } 17       18      return 0; 19  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| a\[0\]\[0\]:	0 a\[0\]\[1\]:	0 a\[1\]\[0\]:	1 a\[1\]\[1\]:	2 a\[2\]\[0\]:	2 a\[2\]\[1\]:	4 a\[3\]\[0\]:	3 a\[3\]\[1\]:	6 a\[4\]\[0\]:	4 a\[4\]\[1\]:	8 |
| :---- |

كما تم شرحه أعلاه، يمكنك الحصول على مصفوفات بأي عدد من الأبعاد، على الرغم من أنه من المحتمل أن تكون معظم المصفوفات التي تقوم بإنشائها ذات بعد واحد أو بعدين.

5. ### **تمرير المصفوفات إلى الدوال**	 {#تمرير-المصفوفات-إلى-الدوال}

كما تم شرحه أعلاه، يمكنك الحصول على الصفوف بأي عدد من الأبعاد، على الرغم من أنه في حالة عدم وجود معظم الصفوف التي يتم تشغيلها بعد واحدة أو بعدين.

الطريقة 1  
المعلمات الرسمية كمؤشر:

| void myFunction(int \*param) { . . . } |
| :---- |

الطريقة 2  
المعلمات الرسمية كمصفوفة ذات حجم:

| void myFunction(int param\[10\]) { . . . } |
| :---- |

الطريقة 3  
المعلمات الرسمية كمصفوفة غير محددة الحجم:

| void myFunction(int param\[\]) { . . . } |
| :---- |

مثال  
الآن، ضع في اعتبارك الدالة التالية، التي تأخذ مصفوفة كحجة مع حجة أخرى وبناءً على الحجج المرسلة، فإنها تعيد متوسط ​​الأرقام التي تم تمريرها عبر المصفوفة على النحو التالي:

|  1  double getAverage(int arr\[\], int size)  2  {  3      int i;  4      double avg;  5      double sum;  6    7      for (i \= 0; i \< size; \++i)  8      {  9          sum \+= arr\[i\]; 10      } 11       12      avg \= sum / size; 13   14      return avg; 15  }  |
| :---- |

الآن، دعونا نستدعي الوظيفة أعلاه على النحو التالي:

|  1  \#include \<stdio.h\>  2    3  /\* function declaration \*/  4  double getAverage(int arr\[\], int size);  5    6  int main ()  7  {  8      /\* an int array with 5 elements \*/  9      int balance\[5\] \= {1000, 2, 3, 17, 50}; 10      double avg; 11   12      /\* pass pointer to the array as an argument \*/  13      avg \= getAverage( balance, 5 ) ; 14   15      /\* output the returned value \*/ 16      printf( "Average value is: %f ", avg ); 17   18      return 0; 19  }  |
| :---- |

عندما يتم تجميع الكود أعلاه معًا وتنفيذه، فإنه ينتج النتيجة التالية:

| Average value is: 214.400000 |
| :---- |

كما ترى، لا يهم طول المصفوفة فيما يتعلق بالوظيفة لأن لغة C لا تقوم بالتحقق من الحدود للمعلمات الرسمية.

6. ### **إرجاع مصفوفة من دالة**	 {#إرجاع-مصفوفة-من-دالة}

إرجاع مصفوفة من دالة  
لا تسمح برمجة C بإرجاع مصفوفة كاملة كحجة إلى دالة. ومع ذلك، يمكنك إرجاع مؤشر إلى مصفوفة من خلال تحديد اسم المصفوفة بدون فهرس.  
إذا كنت تريد إرجاع مصفوفة أحادية البعد من دالة، فيجب عليك إعلان دالة تعيد مؤشرًا كما في المثال التالي:

| int \* myFunction() { . . . } |
| :---- |

النقطة الثانية التي يجب تذكرها هي أن لغة C لا تنصح بإرجاع عنوان متغير محلي إلى خارج الدالة، لذا يتعين عليك تعريف المتغير المحلي كمتغير ثابت.  
الآن، ضع في اعتبارك الدالة التالية التي ستولد 10 أرقام عشوائية وتعيدها باستخدام مصفوفة وتستدعي هذه الدالة على النحو التالي:

|  1  \#include \<stdio.h\>  2    3  /\* function to generate and return random numbers \*/  4  int \* getRandom( )  5  {  6      static int r\[10\];  7      int i;  8    9      /\* set the seed \*/ 10      srand( (unsigned)time( NULL ) ); 11   12      for ( i \= 0; i \< 10; \++i) 13      { 14          r\[i\] \= rand(); 15          printf( "r\[%d\] \= %d\\n", i, r\[i\]); 16      } 17   18      return r; 19  } 20   21   22  /\* main function to call above defined function \*/ 23   24  int main() 25  { 26      int \*p; 27      int i; 28   29      p\=getRandom(); 30   31      for(i\=0; i\<10; i\++) 32      { 33          printf(" i "); 34      } 35   36      return 0; 37  }  |
| :---- |

عندما يتم تجميع الكود أعلاه معًا وتنفيذه، فإنه ينتج النتيجة التالية:

| r\[0\] \= 313959809 r\[1\] \= 1759055877 r\[2\] \= 1113101911 r\[3\] \= 2133832223 r\[4\] \= 2073354073 r\[5\] \= 167288147 r\[6\] \= 1827471542 r\[7\] \= 834791014 r\[8\] \= 1901409888 r\[9\] \= 1990469526 \*(p \+ 0\) : 313959809 \*(p \+ 1\) : 1759055877 \*(p \+ 2\) : 1113101911 \*(p \+ 3\) : 2133832223 \*(p \+ 4\) : 2073354073 \*(p \+ 5\) : 167288147 \*(p \+ 6\) : 1827471542 \*(p \+ 7\) : 834791014 \*(p \+ 8\) : 1901409888 \*(p \+ 9\) : 1990469526 |
| :---- |

7. ### **مؤشر إلى مصفوفة**	 {#مؤشر-إلى-مصفوفة}

مؤشر إلى مصفوفة  
من المرجح أنك لن تفهم هذا القسم حتى تنتهي من الفصل "المؤشرات".  
بافتراض أنك تفهم بعض المؤشرات في لغة C، فلنبدأ: اسم المصفوفة هو مؤشر ثابت إلى العنصر الأول في المصفوفة. لذلك، في الإعلان:

| double balance\[50\]; |
| :---- |

balance هو مؤشر إلى \&balance\[0\]، وهو عنوان العنصر الأول في المصفوفة balance. وبالتالي، يقوم جزء البرنامج التالي بتعيين p كعنوان العنصر الأول في balance:

| double \*p; double balance\[10\];  p \= balance; |
| :---- |

من القانوني استخدام أسماء المصفوفات كمؤشرات ثابتة، والعكس صحيح. لذلك،  
\*(balance \+ 4\) هي طريقة مشروعة للوصول إلى البيانات في balance\[4\].  
بمجرد تخزين عنوان العنصر الأول في "p"، يمكنك الوصول إلى عناصر المصفوفة باستخدام \*p، و\*(p+1)، و\*(p+2)، وما إلى ذلك. فيما يلي مثال لإظهار جميع المفاهيم التي تمت مناقشتها أعلاه:

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      /\* an array with 5 elements \*/  7      double balance\[5\] \= {1000.0, 2.0, 3.4, 17.0, 50.0};  8      double \*p;  9      int i; 10   11      p \= balance; 12   13      /\* output each array element's value \*/ 14      printf( "Array values using pointer\\n"); 15       16      for ( i \= 0; i \< 5; i\++ ) 17      { 18          printf("\*(p \+ %d) : %f\\n", i, \*(p \+ i) ); 19      } 20   21      printf( "Array values using balance as address\\n"); 22       23      for ( i \= 0; i \< 5; i\++ ) 24      { 25          printf("\*(balance \+ %d) : %f\\n", i, \*(balance \+ i) ); 26      } 27   28      return 0; 29  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Array values using pointer \*(p	\+ 0\) :	1000.000000 \*(p	\+ 1\) :	2.000000 \*(p	\+ 2\) :	3.400000 \*(p	\+ 3\) :	17.000000 \*(p	\+ 4\) :	50.000000 Array values using balance as address \*(balance	\+ 0\) :	1000.000000 \*(balance	\+ 1\) :	2.000000 \*(balance	\+ 2\) :	3.400000 \*(balance	\+ 3\) :	17.000000 \*(balance	\+ 4\) :	50.000000 |
| :---- |

في المثال أعلاه، p هو مؤشر إلى double، مما يعني أنه يمكنه تخزين عنوان متغير من نوع double. بمجرد أن نحصل على العنوان في p، سيعطينا \*p القيمة المتاحة في العنوان المخزن في p، كما أظهرنا في المثال أعلاه.

15. # **السلاسل**	 {#السلاسل}

السلاسل هي في الواقع مصفوفة أحادية البعد من الأحرف التي تنتهي بحرف فارغ '\\0'. وبالتالي فإن السلسلة المنتهية بحرف فارغ تحتوي على الأحرف التي تتألف منها السلسلة متبوعة بحرف فارغ.  
يؤدي الإعلان والتهيئة التاليان إلى إنشاء سلسلة تتكون من الكلمة "Hello". للاحتفاظ بالحرف الفارغ في نهاية المصفوفة، يجب أن يكون حجم مصفوفة الأحرف التي تحتوي على السلسلة أكبر بمقدار واحد من عدد الأحرف في الكلمة "Hello".

إذا اتبعت قاعدة تهيئة المصفوفة، فيمكنك كتابة البيان أعلاه على النحو التالي:

| char greeting\[\] \= "Hello"; |
| :---- |

فيما يلي عرض الذاكرة للسلسلة المحددة أعلاه في C/C++:

| index | 0 | 1 | 2 | 3 | 4 | 5 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| var | H | e | l | l | o | \\0 |
| address | 0x9876**1** | 0x9876**2** | 0x9876**3** | 0x9876**4** | 0x9876**5** | 0x9876**6** |

في الواقع، لا تضع الحرف null في نهاية ثابت السلسلة. يضع مُجمِّع C تلقائيًا الحرف '\\0' في نهاية السلسلة عند تهيئة المصفوفة. دعنا نحاول طباعة السلسلة المذكورة أعلاه:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      char greeting\[6\] \= {'H', 'e', 'l', 'l', 'o', '\\0'};  6    7      printf("Greeting message: %s\\n", greeting );  8        9      return 0; 10  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Greeting message: Hello |
| ----: |

يدعم C مجموعة واسعة من الوظائف التي تتعامل مع السلاسل المنتهية بعلامة فارغة:

| Function | Purpose |
| :---- | :---- |
| strcpy(s1, s2); | Copies string s2 into string s1. |
| strcat(s1, s2); | Concatenates string s2 onto the end of string s1. |
| strlen(s1); | Returns the length of string s1. |
| strcmp(s1, s2); | Returns 0 if s1 and s2 are the same; less than 0 if s1\<s2; greater than 0 if s1\>s2. |
| strchr(s1, ch); | Returns a pointer to the first occurrence of character ch in string s1. |
| strstr(s1, s2); | Returns a pointer to the first occurrence of string s2 in string s1. |

يدعم C مجموعة واسعة من الوظائف التي تتعامل مع السلاسل المنتهية بعلامة فارغة:

| \#include \<stdio.h\> \#include \<string.h\> int main () { char str1\[12\] \= "Hello"; char str2\[12\] \= "World"; char str3\[12\]; int len ; /\* copy str1 into str3 \*/ strcpy(str3, str1); printf("strcpy( str3, str1) : %s\\n", str3 ); /\* concatenates str1 and str2 \*/ strcat( str1, str2); printf("strcat( str1, str2): %s\\n", str1 ); /\* total lenghth of str1 after concatenation \*/ len \= strlen(str1); printf("strlen(str1) : %d\\n", len ); return 0; } |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| strcpy( str3, str1) : Hello strcat( str1, str2):	HelloWorld strlen(str1) : 10 |
| :---- |

16. # **المؤشرات**		 {#المؤشرات}

تعتبر المؤشرات في لغة C سهلة وممتعة للتعلم. يتم تنفيذ بعض مهام البرمجة بلغة C بسهولة أكبر باستخدام المؤشرات، ولا يمكن تنفيذ مهام أخرى، مثل تخصيص الذاكرة الديناميكي، بدون استخدام المؤشرات. لذا يصبح من الضروري تعلم المؤشرات لكي تصبح مبرمجًا مثاليًا بلغة C. دعنا نبدأ في تعلمها بخطوات بسيطة وسهلة.

كما تعلم، كل متغير هو موقع ذاكرة وكل موقع ذاكرة له عنوان محدد يمكن الوصول إليه باستخدام عامل الـ (&)، الذي يدل على عنوان في الذاكرة. ضع في اعتبارك المثال التالي، الذي يطبع عنوان المتغيرات المحددة:

|  1  \#include \<stdio.h\>  2    3    4  int main ()  5  {  6      int var1;  7      char var2\[10\];  8    9      printf("Address of var1 variable: %x\\n", &var1 ); 10      printf("Address of var2 variable: %x\\n", &var2 ); 11   12      return 0; 13  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Address of var1 variable: bff5a400 Address of var2 variable: bff5a3f6 |
| ----: |

1. ## **إعلان المؤشر**	 {#إعلان-المؤشر}

المؤشر هو متغير قيمته هي عنوان متغير آخر، أي العنوان المباشر لموقع الذاكرة. مثل أي متغير أو ثابت، يجب عليك إعلان المؤشر قبل استخدامه لتخزين عنوان أي متغير. الشكل العام لإعلان متغير المؤشر هو:

| type \*var-name; |
| ----: |

هنا، type هو النوع الأساسي للمؤشر؛ يجب أن يكون نوع بيانات C صالحًا وvar-name هو اسم متغير المؤشر. النجمة \* المستخدمة لإعلان المؤشر هي نفس النجمة المستخدمة للضرب. ومع ذلك، في هذا البيان، يتم استخدام النجمة لتعيين متغير كمؤشر. ألق نظرة على بعض إعلانات المؤشر الصالحة:

| Int \*ip; double \*dp; float \*fp;  char	\*ch  /\* pointer to an integer \*/ /\* pointer to a double \*/ /\* pointer to a float \*/ /\* pointer to a character \*/ |
| :---- |

إن نوع البيانات الفعلي لقيمة جميع المؤشرات، سواء كانت عددًا صحيحًا أو عددًا عشريًا أو حرفًا أو غير ذلك، هو نفس النوع، وهو رقم سداسي عشري طويل يمثل عنوان ذاكرة. والفرق الوحيد بين المؤشرات من أنواع البيانات المختلفة هو نوع بيانات المتغير أو الثابت الذي يشير إليه المؤشر.

2. ## **كيف تستخدم المؤشرات**		 {#كيف-تستخدم-المؤشرات}

كيف تستخدم المؤشرات؟  
هناك بعض العمليات المهمة، والتي سنقوم بها بمساعدة المؤشرات بشكل متكرر جدًا. (أ) نقوم بتعريف متغير مؤشر، (ب) تعيين عنوان متغير لمؤشر، و(ج) أخيرًا الوصول إلى القيمة الموجودة في العنوان المتاح في متغير المؤشر. يتم ذلك باستخدام عامل أحادي \* الذي يعيد قيمة المتغير الموجود في العنوان المحدد بواسطة المتعامل الخاص به. يستخدم المثال التالي هذه العمليات:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      int var \=   20; /\*  actual variable declaration \*/  6      int \*ip;        /\*  pointer variable declaration \*/  7      ip \= &var;      /\* store address of var in pointer variable\*/  8    9      printf("Address of var variable: %x\\n", &var ); 10   11      /\* address stored in pointer variable \*/ 12      printf("Address stored in ip variable: %x\\n", ip ); 13   14      /\* access the value using the pointer \*/  15      printf("Value of \*ip variable: %d\\n", \*ip ); 16   17      return 0; 18  }  |
| :---- |

كيف تستخدم المؤشرات؟  
هناك بعض العمليات المهمة، والتي ستقوم بمساعدة المؤشرات الهامة للغاية. (أ) تعريف المؤشر البديل، (ب) تعيين عنوان متغير للمؤشر، و(ج) أخيرًا الوصول إلى القيمة الموجودة في العنوان المخصص في التأثير. يتم ذلك باستخدام عامل أحادي \* والذي يعيد قيمة المتغير الموجود في الدليل بواسطة المتعامل الخاص به. يستخدم المثال التالي هذه العمليات:

| Address of var variable: bffd8b3c Address stored in ip variable: bffd8b3c Value of \*ip variable: 20 |
| :---- |

3. ## **مؤشرات NULL**	 {#مؤشرات-null}

مؤشرات NULL  
من الأفضل دائمًا تعيين قيمة NULL لمتغير المؤشر في حالة عدم وجود عنوان دقيق ليتم تعيينه. يتم ذلك في وقت إعلان المتغير. يسمى المؤشر الذي تم تعيين قيمة NULL له مؤشر NULL.  
مؤشر NULL هو ثابت بقيمة صفرية محددة في العديد من المكتبات القياسية. ضع في اعتبارك البرنامج التالي:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      int \*ptr \= NULL;  6    7      printf("The value of ptr is : %x\\n", ptr );  8    9      return 0; 10  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| The value of ptr is 0 |
| ----: |

في أغلب أنظمة التشغيل، لا يُسمح للبرامج بالوصول إلى الذاكرة عند العنوان 0 لأن هذه الذاكرة محجوزة بواسطة نظام التشغيل. ومع ذلك، فإن عنوان الذاكرة 0 له أهمية خاصة؛ فهو يشير إلى أن المؤشر ليس من المفترض أن يشير إلى موقع ذاكرة يمكن الوصول إليه. ولكن وفقًا للاتفاقية، إذا كان المؤشر يحتوي على قيمة فارغة (صفر)، فمن المفترض أنه يشير إلى لا شيء.

للتحقق من وجود مؤشر فارغ، يمكنك استخدام عبارة "if" على النحو التالي:

| if(ptr)     /\* succeeds if p is not null \*/ if(\!ptr)    /\* succeeds if p is null \*/  |
| :---- |

4. ## **المؤشرات بالتفصيل**		 {#المؤشرات-بالتفصيل}

المؤشرات بالتفصيل  
تحتوي المؤشرات على العديد من المفاهيم السهلة وهي مهمة جدًا لبرمجة C. يجب أن تكون مفاهيم المؤشرات المهمة التالية واضحة لأي مبرمج C:

| Concept | Description |
| :---- | :---- |
| Pointer arithmetic | There are four arithmetic operators that can be used in pointers: \++, \--, \+, \- |
| Array of pointers | You can define arrays to hold a number of pointers. |
| Pointer to pointer | C allows you to have pointer on a pointer and so on. |
| Passing pointers to functions in C | Passing an argument by reference or by address enable the passed argument to be changed in the calling function by the called function. |
| Return pointer from functions in C | C allows a function to return a pointer to the local variable, static variable, and dynamically allocated memory as well. |

1. ### **حساب المؤشر**		 {#حساب-المؤشر}

حساب المؤشر  
المؤشر في لغة C هو عنوان، وهو قيمة عددية. وبالتالي، يمكنك إجراء عمليات حسابية على المؤشر تمامًا كما يمكنك إجراء عمليات حسابية على القيمة العددية. هناك أربعة عوامل حسابية يمكن استخدامها على المؤشرات: \++ و-- و+ و-  
لفهم حساب المؤشر، دعنا نعتبر أن ptr هو مؤشر عدد صحيح يشير إلى العنوان 1000\. بافتراض أن الأرقام الصحيحة 32 بت، دعنا نجري العملية الحسابية التالية على المؤشر:

| ptr++ |
| :---- |

بعد العملية السابقة، سيشير ptr إلى الموقع 1004 لأنه في كل مرة يتم فيها زيادة ptr، فإنه سيشير إلى موقع العدد الصحيح التالي الذي يبعد 4 بايتات عن الموقع الحالي. ستنقل هذه العملية المؤشر إلى موقع الذاكرة التالي دون التأثير على القيمة الفعلية في موقع الذاكرة. إذا كان ptr يشير إلى حرف عنوانه 1000، فإن العملية السابقة ستشير إلى الموقع 1001 لأن الحرف التالي سيكون متاحًا عند 1001\.

2. ### **زيادة المؤشر**		 {#زيادة-المؤشر}

زيادة المؤشر  
نفضل استخدام مؤشر في برنامجنا بدلاً من المصفوفة لأن مؤشر المتغير يمكن زيادته، على عكس اسم المصفوفة الذي لا يمكن زيادته لأنه مؤشر ثابت. يقوم البرنامج التالي بزيادة مؤشر المتغير للوصول إلى كل عنصر لاحق في المصفوفة:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 3;  4    5  int main ()  6  {  7      int var\[\] \= {10, 100, 200};  8      int i, \*ptr;  9   10      /\* let us have array address in pointer \*/  11      ptr \= var; 12       13      for ( i \= 0; i \< MAX; i\++) 14      { 15          printf("Address of var\[%d\] \= %x\\n", i, ptr ); 16          printf("Value of var\[%d\] \= %d\\n", i, \*ptr ); 17   18          /\* move to the next location \*/  19          ptr\++; 20      } 21       22      return 0; 23  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Address of var\[0\]	\= bf882b30 Value of var\[0\] \=	10 Address of var\[1\]	\= bf882b34 Value of var\[1\] \=	100 Address of var\[2\]	\= bf882b38 Value of var\[2\] \=	200 |
| :---- |

3. ### **تقليل قيمة المؤشر**	 {#تقليل-قيمة-المؤشر}

تقليل قيمة المؤشر  
تنطبق نفس الاعتبارات على تقليل قيمة المؤشر، مما يؤدي إلى تقليل قيمته بعدد البايتات من نوع البيانات الخاص به كما هو موضح أدناه:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 3;  4    5  int main ()  6  {  7      int var\[\] \= {10, 100, 200};  8      int i, \*ptr;  9   10   11      /\* let us have array address in pointer \*/ 12      ptr \= &var\[MAX\-1\]; 13   14      for ( i \= MAX; i \> 0; i\--) 15      { 16          printf("Address of var\[%d\] \= %x\\n", i, ptr ); 17          printf("Value of var\[%d\] \= %d\\n", i, \*ptr ); 18   19          /\* move to the previous location \*/ 20          ptr\--; 21      } 22   23      return 0; 24  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Address of var\[3\]	\= bfedbcd8 Value of var\[3\] \=	200 Address of var\[2\]	\= bfedbcd4 Value of var\[2\] \=	100 Address of var\[1\]	\= bfedbcd0 Value of var\[1\] \=	10 |
| :---- |

4. ### **مقارنات المؤشرات**		 {#مقارنات-المؤشرات}

مقارنات المؤشرات  
يمكن مقارنة المؤشرات باستخدام عوامل علائقية، مثل \== و\< و\>. إذا كانت p1 وp2 تشيران إلى متغيرات مرتبطة ببعضها البعض، مثل عناصر نفس المصفوفة، فيمكن مقارنة p1 وp2 بشكل مفيد.  
يعدل البرنامج التالي المثال السابق \- بزيادة مؤشر المتغير طالما أن العنوان الذي يشير إليه أقل من أو يساوي عنوان آخر عنصر في المصفوفة، وهو \&var\[MAX \- 1\]:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 3;  4    5  int main ()  6  {  7      int var\[\] \= {10, 100, 200};  8      int i, \*ptr;  9   10      /\* let us have address of the first element in pointer \*/  11      ptr \= var; 12      i \= 0; 13       14      while ( ptr \<= &var\[MAX \- 1\] ) 15      { 16          printf("Address of var\[%d\] \= %x\\n", i, ptr ); 17          printf("Value of var\[%d\] \= %d\\n", i, \*ptr ); 18   19          /\* point to the previous location \*/  20          ptr\++; 21          i\++; 22      } 23       24      return 0; 25  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Address of var\[0\]	\= bfdbcb20 Value of var\[0\] \=	10 Address of var\[1\]	\= bfdbcb24 Value of var\[1\] \=	100 Address of var\[2\]	\= bfdbcb28 Value of var\[2\] \=	200 |
| ----: |

5. ### **مجموعة من المؤشرات**		 {#مجموعة-من-المؤشرات}

مجموعة من المؤشرات  
قبل أن نفهم مفهوم مجموعات المؤشرات، دعونا نفكر في المثال التالي، الذي يستخدم مجموعة من 3 أعداد صحيحة:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 3;  4    5  int main ()  6  {  7      int var\[\] \= {10, 100, 200};  8      int i;  9   10      for (i \= 0; i \< MAX; i\++) 11      { 12          printf("Value of var\[%d\] \= %d\\n", i, var\[i\] ); 13      } 14   15      return 0; 16  }  |
| :---- |

When the above code is compiled and executed, it produces the following result:

| Value of var\[0\] \= 10 Value of var\[1\] \= 100 Value of var\[2\] \= 200 |
| :---- |

قد يكون هناك موقف حيث نريد الحفاظ على مصفوفة يمكنها تخزين مؤشرات إلى عدد صحيح أو حرف أو أي نوع بيانات آخر متاح. فيما يلي إعلان لمصفوفة من المؤشرات إلى عدد صحيح:

| int \*ptr\[MAX\]; |
| :---- |

يعلن ptr كمجموعة من مؤشرات الأعداد الصحيحة MAX. وبالتالي، يحمل كل عنصر في ptr مؤشرًا إلى قيمة int. يستخدم المثال التالي ثلاثة أعداد صحيحة، يتم تخزينها في مجموعة من المؤشرات، على النحو التالي:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 3;  4    5  int main ()  6  {  7      int var\[\] \= {10, 100, 200};  8      int i, \*ptr\[MAX\];  9   10      for ( i \= 0; i \< MAX; i\++) 11      { 12          ptr\[i\] \= &var\[i\]; /\* assign the address of integer. \*/ 13      } 14   15      for ( i \= 0; i \< MAX; i\++) 16      { 17          printf("Value of var\[%d\] \= %d\\n", i, \*ptr\[i\] ); 18      } 19   20      return 0; 21  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of var\[0\] \= 10 Value of var\[1\] \= 100 Value of var\[2\] \= 200 |
| :---- |

يمكنك أيضًا استخدام مجموعة من المؤشرات إلى الأحرف لتخزين قائمة من السلاسل على النحو التالي:

|  1  \#include \<stdio.h\>  2    3  const int MAX \= 4;  4    5  int main ()  6  {  7      char \*names\[\] \=  8      {  9          "Zara Ali", "Hina Ali", "Nuha Ali", "Sara Ali", 10      }; 11   12      int i \= 0; 13   14      for ( i \= 0; i \< MAX; i\++) 15      { 16          printf("Value of names\[%d\] \= %s\\n", i, names\[i\] ); 17      } 18   19      return 0; 20  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of names\[0\] \= Zara Ali Value of names\[1\] \= Hina Ali Value of names\[2\] \= Nuha Ali Value of names\[3\] \= Sara Ali |
| :---- |

6. ### **مؤشر إلى مؤشر**		 {#مؤشر-إلى-مؤشر}

مؤشر إلى مؤشر  
يعد المؤشر إلى مؤشر شكلاً من أشكال التوجيه غير المباشر المتعدد، أو سلسلة من المؤشرات. عادةً، يحتوي المؤشر على عنوان متغير. عندما نقوم بتعريف مؤشر إلى مؤشر، يحتوي المؤشر الأول على عنوان المؤشر الثاني، والذي يشير إلى الموقع الذي يحتوي على القيمة الفعلية كما هو موضح أدناه.

| Pointer X |  | Pointer Y |  | Pointer Z |
| :---: | ----- | :---: | ----- | :---: |
| Address X | \---------\> | Address Y | \---------\> | Address Z |

يجب الإعلان عن المتغير الذي يشير إلى مؤشر على هذا النحو. ويتم ذلك عن طريق وضع علامة نجمة إضافية أمام اسمه. على سبيل المثال، يعلن الإعلان التالي عن مؤشر إلى مؤشر من نوع int:

| int \*\*var; |
| :---- |

عندما يتم الإشارة إلى قيمة مستهدفة بشكل غير مباشر بواسطة مؤشر إلى مؤشر، فإن الوصول إلى تلك القيمة يتطلب تطبيق عامل النجمة مرتين، كما هو موضح أدناه في المثال:

|  1  \#include \<stdio.h\>  2    3  int main ()  4  {  5      int var;  6      int \*ptr;  7      int \*\*pptr;  8    9      var \= 3000; 10   11      /\* take the address of var \*/ 12      ptr \= &var; 13   14      /\* take the address of ptr using address of operator & \*/ 15      pptr \= &ptr; 16   17      /\* take the value using pptr \*/ 18      printf("Value of var \= %d\\n", var ); 19      printf("Value available at \*ptr \= %d\\n", \*ptr ); 20      printf("Value available at \*\*pptr \= %d\\n", \*\*pptr); 21   22      return 0; 23  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of var \= 3000 Value available at \*ptr \= 3000 Value available at \*\*pptr \= 3000 |
| :---- |

7. ### **تمرير المؤشرات إلى الدوال**		 {#تمرير-المؤشرات-إلى-الدوال}

تمرير المؤشرات إلى الدوال  
تسمح برمجة C بتمرير مؤشر إلى دالة. للقيام بذلك، ما عليك سوى إعلان معلمة الدالة كنوع مؤشر.  
فيما يلي مثال بسيط حيث نمرر مؤشرًا طويلًا غير موقّع إلى دالة ونغير القيمة داخل الدالة التي تنعكس مرة أخرى في الدالة المستدعية:

|  1  \#include \<stdio.h\>   2  \#include \<time.h\>  3    4  void getSeconds(unsigned long \*par);  5    6  int main ()  7  {  8      unsigned long sec;  9   10      getSeconds( &sec ); 11   12      /\* print the actual value \*/ 13      printf("Number of seconds: %ld\\n", sec ); 14   15      return 0; 16  } 17   18   19  void getSeconds(unsigned long \*par) 20  { 21      /\* get the current number of seconds \*/ 22      \*par \= time( NULL ); 23   24      return; 25  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Number of seconds :1294450468 |
| :---- |

الوظيفة التي يمكنها قبول مؤشر، يمكنها أيضًا قبول مصفوفة كما هو موضح في المثال التالي:

|  1  \#include \<stdio.h\>  2    3  /\* function declaration \*/  4  double getAverage(int \*arr, int size);  5    6  int main ()  7  {  8      /\* an int array with 5 elements \*/  9      int balance\[5\] \= {1000, 2, 3, 17, 50}; 10      double avg; 11   12      /\* pass pointer to the array as an argument \*/ 13      avg \= getAverage( balance, 5 ) ; 14   15      /\* output the returned value \*/ 16      printf("Average value is: %f\\n", avg ); 17   18      return 0; 19  } 20   21   22  double getAverage(int \*arr, int size) 23  { 24      int i, sum \= 0; 25      double avg; 26   27      for (i \= 0; i \< size; \++i) 28      { 29          sum \+= arr\[i\]; 30      } 31   32      avg \= sum/2; 33   34      return avg; 35  }  |
| :---- |

عندما يتم تجميع الكود أعلاه معًا وتنفيذه، فإنه ينتج النتيجة التالية:

| Average value is: 214.40000 |
| ----: |

8. ### **إرجاع المؤشر من الدوال**		 {#إرجاع-المؤشر-من-الدوال}

إرجاع المؤشر من الدوال  
لقد رأينا في الفصل السابق كيف تسمح برمجة C بإرجاع مصفوفة من دالة. وعلى نحو مماثل، تسمح C أيضًا بإرجاع مؤشر من دالة. للقيام بذلك، يجب عليك إعلان دالة تعيد مؤشرًا كما في المثال التالي:

| int \* myFunction() { . . . } |
| :---- |

النقطة الثانية التي يجب تذكرها هي أنه ليس من الجيد إرجاع عنوان متغير محلي خارج الدالة، لذا سيتعين عليك تعريف المتغير المحلي كمتغير ثابت.  
الآن، ضع في اعتبارك الدالة التالية التي ستولد 10 أرقام عشوائية وتعيدها باستخدام اسم مصفوفة يمثل مؤشرًا، أي عنوان أول عنصر في المصفوفة.

|  1  \#include \<stdio.h\>  2  \#include \<time.h\>  3    4  int \* getRandom()  5  {  6      /\* set the seed \*/  7      srand( (unsigned)time( NULL ) );  8      int r\[10\];  9      int i; 10   11      for ( i \= 0; i \< 10; \++i) 12      { 13          r\[i\] \= rand(); 14          printf("%d\\n", r\[i\] ); 15      } 16   17      return r; 18  } 19   20   21  /\* main function to call above defined function \*/ 22  int main () 23  { 24      /\* a pointer to an int \*/ 25      int \*p; 26      int i; 27   28      p \= getRandom(); 29   30      for ( i \= 0; i \< 10; i\++ ) 31      { 32          printf("\*(p \+ \[%d\]) : %d\\n", i, \*(p \+ i) ); 33      } 34   35      return 0; 36  }  |
| :---- |

عندما يتم تجميع الكود أعلاه معًا وتنفيذه، فإنه ينتج النتيجة التالية:

| 1523198053 1187214107 1108300978 430494959 1421301276  930971084 123250484 106932140 1604461820 149169022  \*(p	\+	\[0\]) :	1523198053 \*(p	\+	\[1\]) :	1187214107 \*(p	\+	\[2\]) :	1108300978 \*(p	\+	\[3\]) :	430494959 \*(p	\+	\[4\]) :	1421301276 \*(p	\+	\[5\]) :	930971084 \*(p	\+	\[6\]) :	123250484 \*(p	\+	\[7\]) :	106932140 \*(p	\+	\[8\]) :	1604461820 \*(p	\+	\[9\]) :	149169022 |
| :---- |

17. #  **حقول البت Bit Fields** 		 {#حقول-البت-bit-fields}

تسمح حقول البت بتعبئة البيانات في بنية. وهذا مفيد بشكل خاص عندما تكون الذاكرة أو تخزين البيانات في أعلى مستويات الجودة. تتضمن الأمثلة النموذجية ما يلي:  
• تعبئة العديد من الكائنات في كلمة آلية، على سبيل المثال، يمكن ضغط علامات بت واحد.  
• قراءة تنسيقات الملفات الخارجية \-- يمكن قراءة تنسيقات الملفات غير القياسية، على سبيل المثال، الأعداد الصحيحة المكونة من 9 بتات.  
تسمح لنا لغة C بالقيام بذلك في تعريف بنية عن طريق وضع :bit length بعد المتغير. على سبيل المثال:

يوضح الجدول التالي العناصر المتغيرة لحقل البت:

| Elements | Description |
| :---- | :---- |
| type | An integer type that determines how a bit-field's value is interpreted. The type may be int, signed int, or unsigned int. |
| member\_name | The name of the bit-field. |
| width | The number of bits in the bit-field. The width must be less than or equal to the bit width of the specified type. |

المتغيرات التي تم تعريفها بعرض محدد مسبقًا تسمى حقول البت. يمكن لحقل البت أن يحتوي على أكثر من بت واحد؛ على سبيل المثال، إذا كنت بحاجة إلى متغير لتخزين قيمة من 0 إلى 7، فيمكنك تعريف حقل بت بعرض 3 بتات على النحو التالي:

18. # **الهياكل**	 {#الهياكل}

تُستخدم الهياكل لتمثيل سجل. لنفترض أنك تريد تتبع كتبك في مكتبة. قد ترغب في تتبع السمات التالية لكل كتاب:

    • Title

    • Author

    • Subject

    • Book ID

 

1. ## **بنية الهيكل** {#بنية-الهيكل}

تعريف البنية  
لتعريف البنية، يجب عليك استخدام عبارة البنية. تحدد عبارة البنية نوعًا جديدًا من البيانات، مع أكثر من عضو واحد. يكون تنسيق عبارة البنية على النحو التالي:

| struct \[structure tag\] { member definition; member definition; ... member definition; } \[one or more structure variables\]; |
| :---- |

إن وسم الهيكل اختياري، وكل تعريف عضو هو تعريف متغير عادي، مثل int i؛ أو float f؛ أو أي تعريف متغير صالح آخر. وفي نهاية تعريف الهيكل، قبل الفاصلة المنقوطة الأخيرة، يمكنك تحديد متغير هيكلي واحد أو أكثر، لكن هذا اختياري. وهذه هي الطريقة التي يمكنك بها إعلان هيكل الكتاب:

| 1  struct Books 2  { 3      char title\[50\]; 4      char author\[50\]; 5      char subject\[100\]; 6      int book\_id; 7  } book;  |
| :---- |

2. ## **الوصول إلى أعضاء الهيكل**		 {#الوصول-إلى-أعضاء-الهيكل}

الوصول إلى أعضاء الهيكل  
للوصول إلى أي عضو في الهيكل، نستخدم عامل وصول العضو (.). يتم ترميز عامل وصول العضو كنقطة بين اسم متغير الهيكل وعضو الهيكل الذي نرغب في الوصول إليه. يمكنك استخدام الكلمة الأساسية struct لتحديد متغيرات نوع الهيكل. يوضح المثال التالي كيفية استخدام هيكل في برنامج:

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3    4  struct Books  5  {  6      char title\[50\];  7      char author\[50\];  8      char subject\[100\];  9      int book\_id; 10  }; 11   12  int main( ) 13  { 14      struct Books Book1; 15      struct Books Book2; 16   17      /\* book 1 specification \*/ 18      strcpy( Book1.title, "C Programming"); 19      strcpy( Book1.author, "Nuha Ali"); 20      strcpy( Book1.subject, "C Programming Tutorial"); 21      Book1.book\_id \= 6495407; 22   23      /\* book 2 specification \*/ 24      strcpy( Book2.title, "Telecom Billing"); 25      strcpy( Book2.author, "Zara Ali"); 26      strcpy( Book2.subject, "Telecom Billing Tutorial"); 27      Book2.book\_id \= 6495700; 28   29      /\* print Book1 info \*/ 30      printf( "Book 1 title   : %s\\n", Book1.title); 31      printf( "Book 1 author  : %s\\n", Book1.author); 32      printf( "Book 1 subject : %s\\n", Book1.subject); 33      printf( "Book 1 book\_id : %d\\n", Book1.book\_id); 34   35      /\* print Book2 info \*/ 36      printf( "Book 2 title   : %s\\n", Book2.title); 37      printf( "Book 2 author  : %s\\n", Book2.author); 38      printf( "Book 2 subject : %s\\n", Book2.subject); 39      printf( "Book 2 book\_id : %d\\n", Book2.book\_id); 40   41      return 0; 42  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Book	1	title : C Programming Book	1	author : Nuha Ali Book	1	subject : C Programming Tutorial Book	1	book\_id : 6495407 Book	2	title : Telecom Billing Book	2	author : Zara Ali Book	2	subject : Telecom Billing Tutorial Book	2	book\_id : 6495700 |
| :---- |

3. ## **الهياكل كحجة دالة**	 {#الهياكل-كحجة-دالة}

الهياكل كحجة دالة  
يمكنك تمرير هيكل كحجة دالة بنفس الطريقة التي تمرر بها أي متغير أو مؤشر آخر.

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3  struct Books  4  {  5      char title\[50\];  6      char author\[50\];  7      char subject\[100\];  8      int book\_id;  9  }; 10   11  /\* function declaration \*/ 12  void printBook( struct Books book ); 13   14  int main( ) 15  { 16      struct Books Book1; /\* Declare Book1 of type Book \*/ 17      struct Books Book2; /\* Declare Book2 of type Book \*/ 18   19      /\* book 1 specification \*/ 20      strcpy( Book1.title, "C Programming"); 21      strcpy( Book1.author, "Nuha Ali"); 22      strcpy( Book1.subject, "C Programming Tutorial"); 23      Book1.book\_id \= 6495407; 24   25      /\* book 2 specification \*/ 26      strcpy( Book2.title, "Telecom Billing"); 27      strcpy( Book2.author, "Zara Ali"); 28      strcpy( Book2.subject, "Telecom Billing Tutorial"); 29      Book2.book\_id \= 6495700; 30   31      /\* print Book1 info \*/ 32      printBook( Book1 ); 33   34      /\* Print Book2 info \*/ 35      printBook( Book2 ); 36   37      return 0; 38  } 39   40  void printBook( struct Books book ) 41  { 42      printf( "Book title   : %s\\n", book.title); 43      printf( "Book author  : %s\\n", book.author); 44      printf( "Book subject : %s\\n", book.subject); 45      printf( "Book book\_id : %d\\n\\n", book.book\_id); 46  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Book title : C Programming Book author : Nuha Ali Book subject : C Programming Tutorial Book book\_id : 6495407 Book title : Telecom Billing Book author : Zara Ali Book subject : Telecom Billing Tutorial Book book\_id : 6495700 |
| :---- |

4. ## **مؤشرات إلى الهياكل**		 {#مؤشرات-إلى-الهياكل}

مؤشرات إلى الهياكل  
يمكنك تعريف مؤشرات إلى الهياكل بنفس الطريقة التي تحدد بها مؤشرًا إلى أي متغير آخر:

| struct Books \*struct\_pointer; |
| :---- |

الآن، يمكنك تخزين عنوان متغير هيكلي في متغير المؤشر المحدد أعلاه. للعثور على عنوان متغير هيكلي، ضع عامل "&" قبل اسم الهيكل على النحو التالي:

| struct\_pointer \= \&Book1; |
| :---- |

للوصول إلى أعضاء الهيكل باستخدام مؤشر إلى هذا الهيكل، يجب عليك استخدام عامل \-\> على النحو التالي:

| struct\_pointer-\>title; |
| :---- |

دعونا نعيد كتابة المثال أعلاه باستخدام مؤشر الهيكل.

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3    4  struct Books  5  {  6      char title\[50\];  7      char author\[50\];  8      char subject\[100\];  9      int book\_id; 10  }; 11   12  /\* function declaration \*/ 13  void printBook( struct Books \*book ); 14   15  int main( ) 16  { 17      struct Books Book1; /\* Declare Book1 of type Book \*/ 18      struct Books Book2; /\* Declare Book2 of type Book \*/ 19   20      /\* book 1 specification \*/ 21      strcpy( Book1.title, "C Programming"); 22      strcpy( Book1.author, "Nuha Ali"); 23      strcpy( Book1.subject, "C Programming Tutorial"); 24      Book1.book\_id \= 6495407; 25   26      /\* book 2 specification \*/ 27      strcpy( Book2.title, "Telecom Billing"); 28      strcpy( Book2.author, "Zara Ali"); 29      strcpy( Book2.subject, "Telecom Billing Tutorial"); 30      Book2.book\_id \= 6495700; 31   32      /\* print Book1 info by passing address of Book1 \*/ 33      printBook( &Book1 ); 34   35      /\* print Book2 info by passing address of Book2 \*/ 36      printBook( &Book2 ); 37   38      return 0; 39  } 40   41  void printBook( struct Books \*book ) 42  { 43      printf( "Book title   : %s\\n", book\-\>title); 44      printf( "Book author  : %s\\n", book\-\>author); 45      printf( "Book subject : %s\\n", book\-\>subject); 46      printf( "Book book\_id : %d\\n\\n", book\-\>book\_id); 47  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Book title : C Programming Book author : Nuha Ali Book subject : C Programming Tutorial Book book\_id : 6495407 Book title : Telecom Billing Book author : Zara Ali Book subject : Telecom Billing Tutorial Book book\_id : 6495700 |
| :---- |

|  1  struct packed\_struct  2  {  3      unsigned int f1:1;  4      unsigned int f2:1;  5      unsigned int f3:1;  6      unsigned int f4:1;  7      unsigned int type:4;  8      unsigned int my\_int:9;  9  } pack;  |
| :---- |

هنا، يحتوي packed\_struct على 6 أعضاء: أربعة أعلام ذات بت واحد f1..f3، ونوع ذو 4 بت، وmy\_int ذو 9 بت.  
تقوم لغة C تلقائيًا بحزم حقول البت أعلاه بشكل مضغوط قدر الإمكان، بشرط أن يكون الحد الأقصى لطول الحقل أقل من أو يساوي طول الكلمة الصحيحة للكمبيوتر. إذا لم يكن الأمر كذلك، فقد تسمح بعض المترجمات بتداخل الذاكرة للحقول، بينما تقوم أخرى بتخزين الحقل التالي في الكلمة التالية.

هنا، يتم طباعة جميع الأعضاء بشكل جيد للغاية لأنه يتم استخدام عضو واحد في كل مرة.	

افترض أن برنامج C الخاص بك يحتوي على عدد من المتغيرات TRUE/FALSE المجمعة في بنية تسمى status، على النحو التالي:

| struct { unsigned int widthValidated; unsigned int heightValidated; } status; |
| :---- |

يتطلب هذا الهيكل 8 بايتات من مساحة الذاكرة، ولكن في الواقع، سنقوم بتخزين إما 0 أو 1 في كل من المتغيرات. توفر لغة البرمجة C طريقة أفضل لاستخدام مساحة الذاكرة في مثل هذه المواقف.  
إذا كنت تستخدم مثل هذه المتغيرات داخل هيكل، فيمكنك تحديد عرض المتغير الذي يخبر مُجمِّع C أنك ستستخدم فقط هذا العدد من البايتات. على سبيل المثال، يمكن إعادة كتابة الهيكل أعلاه على النحو التالي:

| struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status; |
| :---- |

يتطلب الهيكل أعلاه 4 بايتات من مساحة الذاكرة لمتغير الحالة، ولكن سيتم استخدام 2 بت فقط لتخزين القيم.  
إذا كنت ستستخدم ما يصل إلى 32 متغيرًا، كل منها بعرض 1 بت، فإن هيكل الحالة سيستخدم أيضًا 4 بايتات. ومع ذلك، بمجرد حصولك على 33 متغيرًا، فسيخصص الفتحة التالية من الذاكرة وسيبدأ في استخدام 8 بايتات. دعنا نتحقق من المثال التالي لفهم المفهوم:

|  1  \#include \<stdio.h\>   2  \#include \<string.h\>  3    4  /\* define simple structure \*/   5  struct  6  {  7      unsigned int widthValidated;  8      unsigned int heightValidated;  9  } status1; 10   11  /\* define a structure with bit fields \*/  12  struct 13  { 14      unsigned int widthValidated : 1; 15      unsigned int heightValidated : 1; 16  } status2; 17   18  int main( ) 19  { 20      printf( "Memory size occupied by status1 : %d\\n", sizeof(status1)); 21      printf( "Memory size occupied by status2 : %d\\n", sizeof(status2)); 22   23      return 0; 24  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:	

يأخذ إعلان حقل البت الشكل التالي داخل الهيكل:

| struct { type \[member\_name\] : width ; }; |
| :---- |

| struct { unsigned int age : 3; } Age; |
| :---- |

يوجه تعريف البنية أعلاه مُجمِّع C إلى أن متغير العمر سيستخدم 3 بتات فقط لتخزين القيمة. إذا حاولت استخدام أكثر من 3 بتات، فلن يسمح لك بذلك. دعنا نحاول المثال التالي:

|  1  \#include \<stdio.h\>   2  \#include \<string.h\>  3    4  struct  5  {  6      unsigned int age : 3;  7  } Age;  8    9  int main( ) 10  { 11      Age.age \= 4; 12      printf( "Sizeof( Age ) : %d\\n", sizeof(Age) ); 13      printf( "Age.age : %d\\n", Age.age ); 14   15      Age.age \= 7; 16      printf( "Age.age : %d\\n", Age.age ); 17   18      Age.age \= 8; 19      printf( "Age.age : %d\\n", Age.age ); 20   21      return 0; 22  }  |
| :---- |

عندما يتم تجميع الكود أعلاه، فسيتم تجميعه مع تحذير وعند تنفيذه، فإنه ينتج النتيجة التالية:

| Sizeof( Age ) : 4 Age.age : 4 Age.age : 7 Age.age : 0 |
| :---- |

19. # **الاتحاد**		 {#الاتحاد}

الاتحاد هو نوع خاص من البيانات متاح في لغة C يسمح بتخزين أنواع مختلفة من البيانات في نفس موقع الذاكرة. يمكنك تعريف اتحاد به العديد من الأعضاء، ولكن يمكن لعضو واحد فقط أن يحتوي على قيمة في أي وقت معين. توفر الاتحادات طريقة فعالة لاستخدام نفس موقع الذاكرة لأغراض متعددة.

1. ## **تعريف الاتحاد**	 {#تعريف-الاتحاد}

الاتحاد هو نوع خاص من البيانات المتاحة بلغة C المسموح بها بتخزين أنواع مختلفة من البيانات في نفس موقع الذاكرة. يمكنك تعريف الاتحاد بالعديد من الأعضاء، ولكن يمكن لعضو واحد فقط أن يحتوي على قيمة في أي وقت معين. قوة التحمل طريقة فعالة لاستخدام نفس موقع الذاكرة لأغراض متعددة.

| union \[union tag\] { member definition; member definition; ... member definition; } \[one or more union variables\]; |
| :---- |

إن علامة الاتحاد اختيارية، وكل تعريف عضو هو تعريف متغير عادي، مثل int i؛ أو float f؛ أو أي تعريف متغير صالح آخر. وفي نهاية تعريف الاتحاد، قبل الفاصلة المنقوطة الأخيرة، يمكنك تحديد متغير اتحاد واحد أو أكثر، لكن هذا اختياري. وهذه هي الطريقة التي يمكنك بها تعريف نوع اتحاد يسمى Data يحتوي على ثلاثة أعضاء i وf وstr:

| union Data { int i; float f; char str\[20\]; } data; |
| :---- |

الآن، يمكن لمتغير من نوع البيانات تخزين عدد صحيح أو رقم فاصل عائم أو سلسلة من الأحرف. وهذا يعني أنه يمكن استخدام متغير واحد، أي نفس موقع الذاكرة،

لتخزين أنواع متعددة من البيانات. يمكنك استخدام أي أنواع بيانات مدمجة أو محددة من قبل المستخدم داخل اتحاد بناءً على متطلباتك.  
ستكون الذاكرة التي يشغلها الاتحاد كبيرة بما يكفي لاستيعاب أكبر عضو في الاتحاد. على سبيل المثال، في المثال أعلاه، سيشغل نوع البيانات  
20 بايتًا من مساحة الذاكرة لأن هذه هي المساحة القصوى التي يمكن أن يشغلها سلسلة أحرف. يعرض المثال التالي إجمالي حجم الذاكرة التي يشغلها الاتحاد أعلاه:

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3    4  union Data  5  {  6      int i;  7      float f;  8      char str\[20\];  9  }; 10   11  int main( ) 12  { 13      union Data data; 14   15      printf( "Memory size occupied by data : %d\\n", sizeof(data)); 16   17      return 0; 18  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Memory size occupied by data : 20 |
| :---- |

2. ## **الوصول إلى أعضاء الاتحاد**	 {#الوصول-إلى-أعضاء-الاتحاد}

الوصول إلى أعضاء الاتحاد  
للوصول إلى أي عضو في الاتحاد، نستخدم عامل وصول العضو (.). يتم ترميز عامل وصول العضو كنقطة بين اسم متغير الاتحاد وعضو الاتحاد الذي نرغب في الوصول إليه. يمكنك استخدام الكلمة الأساسية union لتحديد متغيرات من نوع الاتحاد. يوضح المثال التالي كيفية استخدام الاتحادات في برنامج:

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3    4  union Data  5  {  6      int i;  7      float f;  8      char str\[20\];  9  }; 10   11  int main( ) 12  { 13      union Data data; 14   15      data.i \= 10; 16      data.f \= 220.5; 17      strcpy( data.str, "C Programming"); 18   19      printf( "data.i : %d\\n", data.i); 20      printf( "data.f : %f\\n", data.f); 21      printf( "data.str : %s\\n", data.str); 22   23      return 0; 24  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| data.i : 1917853763 data.f : 4122360580327794860452759994368.000000 data.str : C Programming |
| :---- |

هنا، يمكننا أن نرى أن قيمتي عضوي i وf في الاتحاد قد تعرضتا للتلف لأن القيمة النهائية المعينة للمتغير قد شغلت موقع الذاكرة وهذا هو السبب في أن قيمة عضو str يتم طباعتها بشكل جيد للغاية.  
الآن دعنا ننظر إلى نفس المثال مرة أخرى حيث سنستخدم متغيرًا واحدًا في كل مرة وهو الغرض الرئيسي من وجود اتحادات:

|  1  \#include \<stdio.h\>  2  \#include \<string.h\>  3    4  union Data  5  {  6      int i;  7      float f;  8      char str\[20\];  9  }; 10   11  int main( ) 12  { 13      union Data data; 14   15      data.i \= 10; 16      printf( "data.i : %d\\n", data.i); 17   18      data.f \= 220.5; 19      printf( "data.f : %f\\n", data.f); 20   21      strcpy( data.str, "C Programming"); 22      printf( "data.str : %s\\n", data.str); 23   24      return 0; 25  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| data.i : 10 data.f : 220.500000 data.str : C Programming |
| :---- |

20. # **الكلمة الرئيسية TYPEDEF**		 {#الكلمة-الرئيسية-typedef}

توفر لغة البرمجة C كلمة أساسية تسمى typedef، والتي يمكنك استخدامها لإعطاء نوع اسمًا جديدًا. فيما يلي مثال لتعريف مصطلح BYTE للأرقام المكونة من بايت واحد:

| typedef unsigned char BYTE; |
| :---- |

بعد تعريف هذا النوع، يمكن استخدام المعرف BYTE كاختصار لنوع الحرف غير الموقّع، على سبيل المثال:

| BYTE b1, b2; |
| :---- |

حسب الاتفاقية، يتم استخدام الأحرف الكبيرة لهذه التعريفات لتذكير المستخدم بأن اسم النوع هو في الواقع اختصار رمزي، ولكن يمكنك استخدام الأحرف الصغيرة، على النحو التالي:

| typedef unsigned char byte; |
| :---- |

يمكنك استخدام typedef لإعطاء اسم لأنواع البيانات التي يحددها المستخدم أيضًا. على سبيل المثال، يمكنك استخدام typedef مع structure لتحديد نوع بيانات جديد ثم استخدام نوع البيانات هذا لتحديد متغيرات البنية مباشرةً على النحو التالي:

|  1  \#include \<stdio.h\>   2  \#include \<string.h\>  3    4  typedef struct Books  5  {  6      char title\[50\];  7      char author\[50\];  8      char subject\[100\];  9      int book\_id; 10  } Book; 11   12  int main( ) 13  { 14      Book book; 15   16      strcpy( book.title, "C Programming"); 17      strcpy( book.author, "Nuha Ali"); 18      strcpy( book.subject, "C Programming Tutorial"); 19      book.book\_id \= 6495407; 20   21      printf( "Book title : %s\\n", book.title); 22      printf( "Book author : %s\\n", book.author); 23      printf( "Book subject : %s\\n", book.subject); 24      printf( "Book book\_id : %d\\n", book.book\_id); 25   26      return 0; 27  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Book title : C Programming Book author : Nuha Ali Book subject : C Programming Tutorial Book book\_id : 6495407 |
| :---- |

1. ## **typedef مقابل \#define**			 {#typedef-مقابل-#define}

\#define هو توجيه C يستخدم أيضًا لتحديد الأسماء المستعارة لأنواع بيانات مختلفة على غرار typedef ولكن مع الاختلافات التالية:  
• يقتصر typedef على إعطاء أسماء رمزية للأنواع فقط، بينما يمكن استخدام \#define لتحديد الأسماء المستعارة للقيم أيضًا، على سبيل المثال، يمكنك تعريف 1 على أنه ONE، إلخ.  
• يتم تنفيذ تفسير typedef بواسطة المترجم بينما تتم معالجة عبارات \#define بواسطة المعالج المسبق.  
يوضح المثال التالي كيفية استخدام \#define في برنامج:

| printf( "Value of FALSE : %d\\n", FALSE); return 0; } |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of TRUE : 1 Value of FALSE : 0 |
| :---- |

21. # **المدخلات والمخرجات**	 {#المدخلات-والمخرجات}

عندما نقول إدخال، فهذا يعني إدخال بعض البيانات إلى برنامج. يمكن إدخال البيانات في شكل ملف أو من سطر الأوامر. توفر برمجة C مجموعة من الوظائف المضمنة لقراءة البيانات المدخلة وإدخالها إلى البرنامج حسب المتطلبات.  
عندما نقول إخراج، فهذا يعني عرض بعض البيانات على الشاشة أو الطابعة أو في أي ملف. توفر برمجة C مجموعة من الوظائف المضمنة لإخراج البيانات على شاشة الكمبيوتر وكذلك حفظها في ملفات نصية أو ثنائية.

1. ## **الملفات القياسية**	 {#الملفات-القياسية}

الملفات القياسية  
تتعامل برمجة C مع جميع الأجهزة باعتبارها ملفات. لذا، تتم معالجة الأجهزة مثل الشاشة بنفس الطريقة التي تتم بها معالجة الملفات، ويتم فتح الملفات الثلاثة التالية تلقائيًا عند تنفيذ برنامج لتوفير الوصول إلى لوحة المفاتيح والشاشة.

| Standard File | File Pointer | Device |
| :---- | :---- | :---- |
| Standard input | stdin | Keyboard |
| Standard output | stdout | Screen |
| Standard error | stderr | Your screen |

مؤشرات الملف هي الوسيلة للوصول إلى الملف لأغراض القراءة والكتابة. يشرح هذا القسم كيفية قراءة القيم من الشاشة وكيفية طباعة النتيجة على الشاشة.

2. ## **دالة  ()getchar   و    ()putchar** 		 {#دالة-()getchar-و-()putchar}

تقوم دالة int getchar(void) بقراءة الحرف المتاح التالي من الشاشة وتعيده كعدد صحيح. تقرأ هذه الدالة حرفًا واحدًا فقط في كل مرة. يمكنك استخدام هذه الطريقة في الحلقة في حالة رغبتك في قراءة أكثر من حرف واحد من الشاشة.  
تقوم دالة int putchar(int c) بوضع الحرف الذي تم تمريره على الشاشة وتعيد نفس الحرف. تضع هذه الدالة حرفًا واحدًا فقط في كل مرة. يمكنك استخدام هذه الطريقة في الحلقة في حالة رغبتك في عرض أكثر من حرف واحد على الشاشة. تحقق من المثال التالي:

|  1  \#include \<stdio.h\>   2    3  int main( )  4  {  5      int c;  6    7      printf( "Enter a value :");  8      c \= getchar( );  9   10      printf( "\\nYou entered: "); 11      putchar( c ); 12   13      return 0; 14  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتظر منك إدخال بعض النصوص. عندما تدخل نصًا وتضغط على Enter، يستمر البرنامج في القراءة ويقرأ حرفًا واحدًا فقط ويعرضه على النحو التالي:

| $./a.out Enter a value : this is a test You entered: t |
| :---- |

3. ## **الدالة gets() و puts()** 			 {#الدالة-gets()-و-puts()}

تقرأ الدالة char \*gets(char \*s) سطرًا من stdin إلى المخزن المؤقت الذي يشير إليه s حتى يتم إما كتابة سطر جديد أو EOF (نهاية الملف).  
تكتب الدالة int puts(const char \*s) السلسلة 's' والسطر الجديد 'a' في stdout.

|  1  \#include \<stdio.h\>   2    3  int main( )  4  {  5      char str\[100\];  6    7      printf( "Enter a value :");  8      gets( str );  9   10      printf( "\\nYou entered: "); 11      puts( str ); 12   13      return 0; 14  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتظر منك إدخال بعض النصوص. عندما تدخل نصًا وتضغط على Enter، يستمر البرنامج في قراءة السطر بالكامل حتى النهاية، ويعرضه على النحو التالي:

| $./a.out Enter a value : this is test You entered: This is test |
| :---- |

4. ## **دالة scanf() و printf()**  	 {#دالة-scanf()-و-printf()}

تقرأ دالة int scanf(const char \*format, ...) المدخلات من مجرى الإدخال القياسي stdin وتفحص هذا المدخل وفقًا للتنسيق المقدم.  
تكتب دالة int printf(const char \*format, ...) المخرجات إلى مجرى الإخراج القياسي stdout وتنتج المخرجات وفقًا للتنسيق المقدم.  
يمكن أن يكون التنسيق عبارة عن سلسلة ثابتة بسيطة، ولكن يمكنك تحديد %s، %d، %c،  
%f، إلخ، لطباعة أو قراءة السلاسل، أو الأعداد الصحيحة، أو الأحرف، أو الأعداد العشرية، على التوالي. هناك العديد من خيارات التنسيق الأخرى المتاحة والتي يمكن استخدامها بناءً على المتطلبات. دعنا الآن ننتقل إلى مثال بسيط لفهم المفاهيم بشكل أفضل:

|  1  \#include \<stdio.h\>   2    3  int main( )  4  {  5      char str\[100\];  6      int i;  7    8      printf( "Enter a value :");  9      scanf("%s %d", str, &i); 10   11      printf( "\\nYou entered: %s %d ", str, i); 12   13      return 0; 14  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتظر منك إدخال بعض النصوص. عندما تدخل نصًا وتضغط على Enter، يبدأ البرنامج في قراءة النص المدخل ويعرضه على النحو التالي:

| $./a.out Enter a value : seven 7 You entered: seven 7 |
| :---- |

هنا، يجب ملاحظة أن scanf() تتوقع إدخالًا بنفس التنسيق الذي قدمته %s و%d، مما يعني أنه يتعين عليك تقديم مدخلات صالحة مثل "string integer". إذا قدمت "string string" أو "integer integer"، فسيتم افتراض أن هذا إدخال خاطئ. ثانيًا، أثناء قراءة سلسلة، تتوقف scanf() عن القراءة بمجرد مواجهتها لمسافة، لذا فإن "هذا اختبار" عبارة عن ثلاث سلاسل لـ scanf().

22. # **إدخال/إخراج الملف**	 {#إدخال/إخراج-الملف}

لقد شرح الفصل الأخير أجهزة الإدخال والإخراج القياسية التي تتعامل معها لغة البرمجة C. ويغطي هذا الفصل كيف يمكن لمبرمجي C إنشاء ملفات نصية أو ثنائية أو فتحها أو إغلاقها لتخزين البيانات الخاصة بهم.  
يمثل الملف سلسلة من البايتات، بغض النظر عما إذا كان ملف نصي أو ملف ثنائي. توفر لغة البرمجة C إمكانية الوصول إلى الوظائف عالية المستوى بالإضافة إلى المكالمات منخفضة المستوى (مستوى نظام التشغيل) للتعامل مع الملف على أجهزة التخزين الخاصة بك. سيأخذك هذا الفصل خلال المكالمات المهمة لإدارة الملفات.

1. ## **فتح ملف**	 {#فتح-ملف}

يمكنك استخدام الدالة fopen( ) لإنشاء ملف جديد أو لفتح ملف موجود. ستقوم هذه الدعوة بتهيئة كائن من نوع FILE، والذي يحتوي على جميع المعلومات اللازمة للتحكم في التدفق. النموذج الأولي لهذه الدعوة هو كما يلي:

| FILE \*fopen( const char \* filename, const char \* mode ); |
| ----: |

هنا، اسم الملف هو سلسلة نصية، والتي ستستخدمها لتسمية ملفك، ويمكن أن يحتوي وضع الوصول على إحدى القيم التالية:

وصف الوضع

| Mode | Description |
| :---- | :---- |
| r | Opens an existing text file for reading purpose. |
| w | Opens a text file for writing. If it does not exist, then a new file is created. Here your program will start writing content from the beginning of the file. |
| a | Opens a text file for writing in appending mode. If it does not exist, then a new file is created. Here your program will start appending content in the existing file content. |
| r+ | Opens a text file for both reading and writing. |
| w+ | Opens a text file for both reading and writing. It first truncates the file to zero length if it exists, otherwise creates a file if it does not exist. |

| a+ | Opens a text file for both reading and writing. It creates the file if it does not exist. The reading will start from the beginning but writing can only be appended. |
| :---- | :---- |

إذا كنت تريد التعامل مع الملفات الثنائية، فسوف تستخدم أوضاع الوصول التالية بدلاً من الأوضاع المذكورة أعلاه:

| "rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b" |
| :---- |

2. ## **إغلاق ملف**	 {#إغلاق-ملف}

إغلاق ملف  
لإغلاق ملف، استخدم الدالة fclose( ). النموذج الأولي لهذه الدالة هو:

| int fclose( FILE \*fp ); |
| :---- |

تعيد الدالة fclose() القيمة صفر في حالة النجاح، أو EOF في حالة وجود خطأ في إغلاق الملف. تقوم هذه الدالة فعليًا بتفريغ أي بيانات لا تزال معلقة في المخزن المؤقت إلى الملف، وإغلاق الملف، وتحرير أي ذاكرة مستخدمة للملف. EOF هو ثابت محدد في ملف الرأس stdio.h.  
هناك العديد من الوظائف التي توفرها مكتبة C القياسية لقراءة وكتابة ملف، حرفًا بحرف، أو في شكل سلسلة بطول ثابت.

3. ## **كتابة ملف**	 {#كتابة-ملف}

كتابة ملف  
فيما يلي أبسط وظيفة لكتابة أحرف فردية في مجرى:

| int fputc( int c, FILE \*fp ); |
| :---- |

تكتب الدالة fputc() قيمة الحرف للوسيطة c في مجرى الإخراج المشار إليه بواسطة fp. وتعيد الحرف المكتوب في حالة النجاح وإلا في حالة وجود خطأ. يمكنك استخدام الدوال التالية لكتابة سلسلة منتهية بعلامة فارغة في مجرى الإخراج:

| int fputs( const char \*s, FILE \*fp ); |
| :---- |

تكتب الدالة fputs() السلسلة s في مجرى الإخراج المشار إليه بواسطة fp. وتعيد قيمة غير سالبة في حالة النجاح، وإلا يتم إرجاع EOF في حالة حدوث أي خطأ. يمكنك أيضًا استخدام الدالة int fprintf(FILE \*fp,const char \*format, ...) لكتابة سلسلة في ملف. جرّب المثال التالي.  
تأكد من توفر دليل /tmp. إذا لم يكن كذلك، فيجب عليك قبل المتابعة إنشاء هذا الدليل على جهازك.

| \#include \<stdio.h\> main() { FILE \*fp; fp \= fopen("/tmp/test.txt", "w+"); fprintf(fp, "This is testing for fprintf...\\n"); fputs("This is testing for fputs...\\n", fp); fclose(fp); }  |
| ----- |

عند تجميع الكود أعلاه وتنفيذه، فإنه ينشئ ملفًا جديدًا باسم test.txt في دليل  
/tmp ويكتب سطرين باستخدام دالتين مختلفتين. دعنا نقرأ هذا الملف في القسم التالي.

4. ## **قراءة ملف**	 {#قراءة-ملف}

قراءة ملف  
فيما يلي أبسط وظيفة لقراءة حرف واحد من ملف:

| int fgetc( FILE \* fp ); |
| ----: |

تقرأ الدالة fgetc() حرفًا من ملف الإدخال المشار إليه بواسطة fp. قيمة الإرجاع هي الحرف المقروء، أو في حالة حدوث أي خطأ، ترجع EOF. تسمح الدالة التالية بقراءة سلسلة من مجرى:

| char \*fgets( char \*buf, int n, FILE \*fp ); |
| ----: |

تقرأ الدالة fgets() ما يصل إلى n \- 1 حرف من مجرى الإدخال الذي يشير إليه fp. وتنسخ السلسلة المقروءة إلى المخزن المؤقت buf، وتضيف حرفًا فارغًا لإنهاء السلسلة.  
إذا واجهت هذه الدالة حرف سطر جديد '\\n' أو نهاية الملف EOF قبل قراءة الحد الأقصى لعدد الأحرف، فإنها تعيد فقط الأحرف المقروءة حتى تلك النقطة بما في ذلك حرف السطر الجديد. يمكنك أيضًا استخدام الدالة int fscanf(FILE \*fp, const char \*format, ...) لقراءة السلاسل من ملف، لكنها تتوقف عن القراءة بعد مواجهة حرف المسافة الأول.

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      FILE \*fp;  6      char buff\[255\];  7    8      fp \= fopen("/tmp/test.txt", "r");  9      fscanf(fp, "%s", buff); 10      printf("1 : %s\\n", buff ); 11   12      fgets(buff, 255, (FILE\*)fp); 13      printf("2: %s\\n", buff ); 14   15      fgets(buff, 255, (FILE\*)fp); 16      printf("3: %s\\n", buff ); 17      fclose(fp); 18  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه يقرأ الملف الذي تم إنشاؤه في القسم السابق وينتج النتيجة التالية:

| 1 : This 2: is testing for fprintf... 3: This is testing for fputs... |
| :---- |

دعونا نرى بمزيد من التفصيل ما حدث هنا. أولاً، تقرأ الدالة fscanf() هذا فقط لأنها بعد ذلك واجهت مسافة، والمكالمة الثانية هي لدالة fgets() التي تقرأ السطر المتبقي حتى تواجه نهاية السطر. وأخيرًا، تقرأ الدالة fgets() السطر الثاني بالكامل.

5. ## **إدخال وإخراج البيانات الثنائية**	 {#إدخال-وإخراج-البيانات-الثنائية}

هناك دالتان يمكن استخدامهما لإدخال وإخراج البيانات الثنائية:  
يجب استخدام كلتا الدالتين لقراءة أو كتابة كتل من الذاكرة \- عادةً المصفوفات أو الهياكل.

 

23. # **المعالج المسبق**		 {#المعالج-المسبق}

لا يعد المعالج المسبق للغة C جزءًا من المترجم، بل هو خطوة منفصلة في عملية التجميع. وبعبارات بسيطة، يعد المعالج المسبق للغة C مجرد أداة لاستبدال النص ويعطي التعليمات للمترجم للقيام بالمعالجة المسبقة المطلوبة قبل التجميع الفعلي. سنشير إلى المعالج المسبق للغة C باسم CPP.  
تبدأ جميع أوامر المعالج المسبق برمز التجزئة (\#). يجب أن يكون أول حرف غير فارغ، ولتسهيل القراءة، يجب أن تبدأ تعليمات المعالج المسبق في العمود الأول. يسرد القسم التالي جميع تعليمات المعالج المسبق المهمة:

| Directive | Description |
| :---- | :---- |
| \#define | Substitutes a preprocessor macro. |
| \#include | Inserts a particular header from another file. |
| \#undef | Undefines a preprocessor macro. |
| \#ifdef | Returns true if this macro is defined. |
| \#ifndef | Returns true if this macro is not defined. |
| \#if | Tests if a compile time condition is true. |
| \#else | The alternative for \#if. |
| \#elif | \#else and \#if in one statement. |
| \#endif | Ends preprocessor conditional. |
| \#error | Prints error message on stderr. |
| \#pragma | Issues special commands to the compiler, using a standardized method. |

 

1. ## **أمثلة** {#أمثلة}

قم بتحليل الأمثلة التالية لفهم التوجيهات المختلفة.

| \#define MAX\_ARRAY\_LENGTH 20 |
| :---- |

تخبر هذه التوجيهة CPP باستبدال مثيلات MAX\_ARRAY\_LENGTH بـ 20\. استخدم \#define للثوابت لزيادة قابلية القراءة.

| \#include \<stdio.h\> \#include "my\_header.h" |
| :---- |

تخبر هذه التوجيهات CPP بالحصول على stdio.h من مكتبات النظام وإضافة النص إلى ملف المصدر الحالي. يخبر السطر التالي CPP بالحصول على myheader.h من الدليل المحلي وإضافة المحتوى إلى ملف المصدر الحالي.

| \#undef FILE\_SIZE \#define FILE\_SIZE 42 |
| :---- |

يخبر CPP بإلغاء تعريف FILE\_SIZE الموجود وتعريفه على أنه 42\.

| \#ifndef MESSAGE \#define MESSAGE "You wish\!" \#endif |
| :---- |

يخبر CPP بتعريف MESSAGE فقط إذا لم يتم تعريف MESSAGE بالفعل.

| \#ifdef DEBUG /\* Your debugging statements here \*/ \#endif |
| :---- |

يخبر CPP بمعالجة العبارات المرفقة إذا تم تعريف DEBUG. وهذا مفيد إذا قمت بتمرير علامة \-DDEBUG إلى مُجمِّع gcc في وقت التجميع. سيؤدي هذا إلى تعريف DEBUG، حتى تتمكن من تشغيل التصحيح وإيقافه أثناء التجميع.

2. ## **وحدات الماكرو المحددة مسبقًا**	 {#وحدات-الماكرو-المحددة-مسبقًا}

وحدات الماكرو المحددة مسبقًا  
يحدد ANSI C عددًا من وحدات الماكرو. وعلى الرغم من أن كل وحدة ماكرو متاحة للاستخدام في البرمجة، فلا ينبغي تعديل وحدات الماكرو المحددة مسبقًا بشكل مباشر.

| Macro | Description |
| :---- | :---- |
| \_\_DATE | The current date as a character literal in "MMM DD YYYY" format. |
| \_\_TIME | The current time as a character literal in "HH:MM:SS" format. |
| \_\_FILE | This contains the current filename as a string literal. |
| \_\_LINE | This contains the current line number as a decimal constant. |
| \_\_STDC | Defined as 1 when the compiler complies with the ANSI standard. |

دعونا نحاول المثال التالي:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      printf("File    :%s\\n",  FILE  );  6      printf("Date    :%s\\n",  DATE  );  7      printf("Time    :%s\\n",  TIME  );  8      printf("Line    :%d\\n",  LINE  );  9      printf("ANSI    :%d\\n",  STDC  ); 10  }  |
| :---- |

عندما يتم تجميع الكود أعلاه في ملف test.c وتنفيذه، فإنه ينتج النتيجة التالية:

| File :test.c Date :Jun 2 2012 Time :03:36:24 Line :8 ANSI :1 |
| :---- |

3. ## **مشغلات المعالج المسبق**	 {#مشغلات-المعالج-المسبق}

مشغلات المعالج المسبق  
يوفر المعالج المسبق للغة C المشغلات التالية للمساعدة في إنشاء وحدات الماكرو:

1. ### **عامل استمرار الماكرو (\\)**		 {#عامل-استمرار-الماكرو-(\)}

عامل استمرار الماكرو (\\)  
عادةً ما يقتصر الماكرو على سطر واحد. يُستخدم عامل استمرار الماكرو (\\) لاستمرار ماكرو أطول من اللازم لسطر واحد. على سبيل المثال:

|    \#define message\_for(a, b) \\    printf(\#a " and " \#b ": We love you\!\\n") |
| :---- |

2. ### **عامل تحويل السلسلة (\#)**		 {#عامل-تحويل-السلسلة-(#)}

عامل تحويل السلسلة (\#)  
عند استخدام عامل تحويل السلسلة أو عامل علامة الرقم (\#) ضمن تعريف ماكرو، يحول معلمة ماكرو إلى ثابت سلسلة. لا يمكن استخدام هذا العامل إلا في ماكرو يحتوي على وسيطة محددة أو قائمة معلمات. على سبيل المثال:

|  1  \#include \<stdio.h\>  2    3  \#define message\_for(a, b) \\  4  printf(\#a " and " \#b ": We love you\!\\n")  5    6  int main(void)  7  {  8      message\_for(Carole, Debra);  9       10      return 0; 11  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Carole and Debra: We love you\! |
| ----: |

3. ### **عامل لصق الرمز (\#\#)**	 {#عامل-لصق-الرمز-(##)}

عامل لصق الرمز (\#\#)  
يعمل عامل لصق الرمز (\#\#) داخل تعريف الماكرو على الجمع بين وسيطتين. فهو يسمح بضم رمزين منفصلين في تعريف الماكرو إلى رمز واحد. على سبيل المثال:

|  1  \#include \<stdio.h\>  2    3  \#define tokenpaster(n) printf ("token" \#n " \= %d", token\#\#n)  4    5    6  int main(void)  7  {  8      int token34 \= 40;  9   10      tokenpaster(34); 11       12      return 0; 13  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| token34 \= 40 |
| ----: |

لقد حدث ذلك لأن هذا المثال يؤدي إلى الإخراج الفعلي التالي من المعالج المسبق:

| printf ("token34 \= %d", token34); |
| ----: |

يوضح هذا المثال عملية تجميع الرمز المميز n في الرمز المميز 34 وهنا استخدمنا كل من التحويل إلى نص ولصق الرمز المميز.

4. ### **عامل Defined()**	 {#عامل-defined()}

عامل Defined()  
يستخدم عامل Defined الذي تم تعريفه بواسطة المعالج المسبق في التعبيرات الثابتة لتحديد ما إذا كان المعرف محددًا باستخدام \#define. إذا تم تعريف المعرف المحدد، تكون القيمة صحيحة (غير صفرية). إذا لم يتم تعريف الرمز، تكون القيمة خاطئة (صفرية). يتم تحديد عامل Defined على النحو التالي:

|  1  \#include \<stdio.h\>  2    3  \#if \!defined (MESSAGE)  4  \#define MESSAGE "You wish\!"  5  \#endif  6    7  int main(void)  8  {  9      printf("Here is the message: %s\\n", MESSAGE); 10   11      return 0; 12  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Here is the message: You wish\! |
| :---- |

4. ##  **وحدات الماكرو ذات المعلمات**		 {#وحدات-الماكرو-ذات-المعلمات}

 وحدات الماكرو ذات المعلمات  
تتمثل إحدى الوظائف القوية في CPP في القدرة على محاكاة الوظائف باستخدام وحدات الماكرو ذات المعلمات. على سبيل المثال، قد يكون لدينا بعض التعليمات البرمجية لتربيع رقم على النحو التالي:

| int square(int x)  {     return x \* x; } |
| :---- |

يمكننا إعادة كتابة الكود أعلاه باستخدام الماكرو على النحو التالي:

| \#define square(x) ((x) \* (x)) |
| :---- |

يجب تعريف وحدات الماكرو ذات الوسائط باستخدام التوجيه \#define قبل أن يمكن استخدامها. يتم وضع قائمة الوسائط بين قوسين ويجب أن تأتي بعد اسم الماكرو مباشرة. لا يُسمح بوجود مسافات بين اسم الماكرو والقوس المفتوح. على سبيل المثال:

|  1  \#include \<stdio.h\>  2    3  \#define MAX(x,y) ((x) \> (y) ? (x) : (y))  4    5  int main(void)  6  {  7      printf("Max between 20 and 10 is %d\\n", MAX(10, 20));  8    9      return 0; 10  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Max between 20 and 10 is 20 |
| :---- |

24. # **ملف الرأس HEADER FILES**	 {#ملف-الرأس-header-files}

ملف الرأس هو ملف يحمل الامتداد .h والذي يحتوي على إعلانات وظائف C وتعريفات وحدات الماكرو التي سيتم مشاركتها بين العديد من ملفات المصدر. هناك نوعان من ملفات الرأس: الملفات التي يكتبها المبرمج والملفات التي تأتي مع المجمِّع.  
تطلب استخدام ملف رأس في برنامجك عن طريق تضمينه باستخدام توجيه المعالجة المسبقة للغة C \#include، كما رأيت تضمين ملف الرأس stdio.h، والذي يأتي مع المجمِّع.  
يُعادل تضمين ملف الرأس نسخ محتوى ملف الرأس ولكننا لا نفعل ذلك لأنه سيكون عرضة للخطأ وليس من الجيد نسخ محتوى ملف الرأس في ملفات المصدر، خاصةً إذا كان لدينا ملفات مصدر متعددة في برنامج.  
تتمثل إحدى الممارسات البسيطة في برامج C أو C++ في الاحتفاظ بجميع الثوابت ووحدات الماكرو والمتغيرات العالمية على مستوى النظام ونماذج الوظائف الأولية في ملفات الرأس وتضمين ملف الرأس هذا أينما كان مطلوبًا.

1. ## **التضمين Include**  	 {#التضمين-include}

 تضمين بناء الجملة  
يتم تضمين كل من ملفات رأس المستخدم والنظام باستخدام توجيه المعالجة المسبقة \#include. وهو يتخذ الشكلين التاليين:

| \#include \<file\> |
| :---- |

يُستخدم هذا النموذج لملفات رأس النظام. فهو يبحث عن ملف باسم "ملف" في قائمة قياسية من أدلة النظام. يمكنك إضافة أدلة إلى هذه القائمة باستخدام الخيار \-I أثناء تجميع الكود المصدر.

| \#include "file" |
| :---- |

يُستخدم هذا النموذج لملفات الرأس الخاصة ببرنامجك الخاص. فهو يبحث عن ملف باسم "file" في الدليل الذي يحتوي على الملف الحالي. ويمكنك إضافة أدلة إلى هذه القائمة باستخدام الخيار \-I أثناء تجميع الكود المصدر.

2. ## **عملية التضمين**		 {#عملية-التضمين}

 عملية التضمين  
تعمل التعليمات البرمجية \#include بتوجيه المعالج المسبق للغة C لمسح الملف المحدد كمدخل قبل المتابعة ببقية ملف المصدر الحالي. تحتوي المخرجات من المعالج المسبق على المخرجات التي تم إنشاؤها بالفعل، متبوعة بالمخرجات الناتجة عن الملف المضمن، متبوعة بالمخرجات التي تأتي من النص بعد التعليمات البرمجية \#include. على سبيل المثال، إذا كان لديك ملف رأس header.h، فسيكون الأمر على النحو التالي:

| char \*test (void); |
| :---- |

وبرنامج رئيسي يسمى program.c والذي يستخدم ملف الرأس، مثل هذا:

| 1  int x; 2   3  \#include "header.h" 4   5  int main (void) 6  { 7      puts ( test () ); 8  }  |
| :---- |

سوف يرى المترجم نفس تدفق الرمز كما لو كان البرنامج c يقرأ.

| 1  int x; 2   3  char \*test (void); 4   5  int main (void) 6  { 7      puts ( test () ); 8  }  |
| :---- |

3. ## **العناوين التي يتم عرضها مرة واحدة فقط**	 {#العناوين-التي-يتم-عرضها-مرة-واحدة-فقط}

العناوين التي يتم عرضها مرة واحدة فقط  
إذا حدث وتم تضمين ملف العنوان مرتين، فسوف يقوم المترجم بمعالجة محتوياته مرتين وسيؤدي ذلك إلى حدوث خطأ. الطريقة القياسية لمنع حدوث ذلك هي تضمين المحتويات الحقيقية بالكامل للملف في شرط، مثل هذا:

| \#ifndef HEADER\_FILE \#define HEADER\_FILE  the entire header file file  \#endif |
| ----- |

يُعرف هذا البناء عادةً باسم الغلاف \#ifndef. عندما يتم تضمين الرأس مرة أخرى، يصبح الشرط خاطئًا، لأن HEADER\_FILE مُعرَّف. سيتخطى المعالج المسبق محتويات الملف بالكامل، ولن يراه المترجم مرتين.

4. ## **التضمين المحسوب**	 {#التضمين-المحسوب}

في بعض الأحيان، من الضروري تحديد أحد ملفات الرأس المختلفة التي سيتم تضمينها في برنامجك. على سبيل المثال، قد تحدد هذه الملفات معلمات التكوين التي سيتم استخدامها على أنواع مختلفة من أنظمة التشغيل. يمكنك القيام بذلك باستخدام سلسلة من الشروط على النحو التالي:

| \#if SYSTEM\_1 \# include "system\_1.h" \#elif SYSTEM\_2 \# include "system\_2.h" \#elif SYSTEM\_3 ... \#endif |
| :---- |

ولكن مع نموه، يصبح الأمر مملًا، وبدلاً من ذلك يقدم المعالج المسبق القدرة على استخدام ماكرو لاسم الرأس. وهذا ما يسمى بالتضمين المحسوب. فبدلاً من كتابة اسم رأس كحجة مباشرة لـ \#include، يمكنك ببساطة وضع اسم ماكرو هناك:

| \#define SYSTEM\_H "system\_1.h" ... \#include SYSTEM\_H |
| :---- |

سيتم توسيع SYSTEM\_H، وسيبحث المعالج المسبق عن system\_1.h كما لو كان \#include قد تم كتابته بهذه الطريقة في الأصل. يمكن تعريف SYSTEM\_H بواسطة Makefile الخاص بك باستخدام الخيار \-D.

25. # **تحويل النوع TYPE CASTING** 		 {#تحويل-النوع-type-casting}

تحويل النوع هو طريقة لتحويل متغير من نوع بيانات إلى نوع بيانات آخر. على سبيل المثال، إذا كنت تريد تخزين قيمة "long" إلى عدد صحيح بسيط، فيمكنك تحويل النوع "long" إلى "int". يمكنك تحويل القيم من نوع إلى آخر صراحةً باستخدام عامل التحويل على النحو التالي:

| (type\_name) expression |
| :---- |

فكر في المثال التالي حيث يتسبب عامل الإرسال في إجراء قسمة متغير عدد صحيح واحد على آخر كعملية فاصلة عائمة:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int sum \= 17, count \= 5;  6      double mean;  7    8      mean \= (double) sum / count;  9       10      printf("Value of mean : %f\\n", mean ); 11   12  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of mean : 3.400000 |
| :---- |

تجدر الإشارة هنا إلى أن عامل التحويل له الأولوية على القسمة، لذا يتم تحويل قيمة المجموع أولاً إلى نوع double وأخيراً يتم تقسيمها على count مما ينتج عنه قيمة double.  
يمكن أن تكون تحويلات النوع ضمنية والتي يتم إجراؤها بواسطة المترجم تلقائيًا، أو يمكن تحديدها صراحةً من خلال استخدام عامل التحويل. يعتبر استخدام عامل التحويل كلما كانت تحويلات النوع ضرورية ممارسة برمجة جيدة.

1. ## **ترقية الأعداد الصحيحة**	 {#ترقية-الأعداد-الصحيحة}

ترقية الأعداد الصحيحة  
ترقية الأعداد الصحيحة هي العملية التي يتم من خلالها تحويل قيم النوع الصحيح "الأصغر" من int أو int غير الموقّع إلى int أو int غير موقّع. ضع في اعتبارك مثالاً لإضافة حرف إلى عدد صحيح:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int i \= 17;  6      char c \= 'c'; /\* ascii value is 99 \*/   7      int sum;  8    9      sum \= i \+ c; 10       11      printf("Value of sum : %d\\n", sum ); 12  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of sum : 116 |
| :---- |

هنا، قيمة المجموع هي 116 لأن المترجم يقوم بالترقية الصحيحة وتحويل قيمة 'c' إلى ASCII قبل إجراء عملية الجمع الفعلية.

2. ##  **التحويل الحسابي المعتاد**	 {#التحويل-الحسابي-المعتاد}

 التحويل الحسابي المعتاد  
يتم إجراء التحويلات الحسابية المعتادة ضمناً لتحويل قيمها إلى نوع مشترك. يقوم المترجم أولاً بإجراء ترقية الأعداد الصحيحة؛ إذا كانت المتغيرات لا تزال تحتوي على أنواع مختلفة، فسيتم تحويلها إلى النوع الذي يظهر أعلى في التسلسل الهرمي التالي:

لا يتم إجراء التحويلات الحسابية المعتادة لعوامل التعيين، ولا بالنسبة للعوامل المنطقية && و||. دعنا نأخذ المثال التالي لفهم المفهوم:

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      int i \= 17;  6      char c \= 'c'; /\* ascii value is 99 \*/   7      float sum;  8    9      sum \= i \+ c; 10       11      printf("Value of sum : %f\\n", sum ); 12   13  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of sum : 116.000000 |
| :---- |

هنا، من السهل فهم أن أول حرف c يتم تحويله إلى عدد صحيح، ولكن بما أن القيمة النهائية هي double، يتم تطبيق التحويل الحسابي المعتاد ويقوم المترجم بتحويل i وc إلى "float" ويجمعهما مما يؤدي إلى نتيجة "float".

26. # **معالجة الأخطاء**		 {#معالجة-الأخطاء}

على هذا النحو، لا توفر برمجة C دعمًا مباشرًا لمعالجة الأخطاء ولكن كونها لغة برمجة نظام، فإنها توفر لك الوصول إلى مستوى أدنى في شكل قيم إرجاع. ترجع معظم استدعاءات وظائف C أو حتى Unix القيمة \-1 أو NULL في حالة حدوث أي خطأ وتحدد رمز الخطأ errno. يتم تعيينه كمتغير عالمي ويشير إلى حدوث خطأ أثناء أي استدعاء وظيفة. يمكنك العثور على رموز خطأ مختلفة محددة في ملف الرأس \<error.h\>.  
لذلك يمكن لمبرمج C التحقق من القيم المرتجعة ويمكنه اتخاذ الإجراء المناسب بناءً على قيمة الإرجاع. من الممارسات الجيدة تعيين errno إلى 0 في وقت تهيئة البرنامج. تشير القيمة 0 إلى عدم وجود خطأ في البرنامج.

1. ## **errno, perror(), و strerror()**	 {#errno,-perror(),-و-strerror()}

 errno, perror(), and strerror()	

توفر لغة البرمجة C الدالتين perror() وstrerror() اللتين يمكن استخدامهما لعرض الرسالة النصية المرتبطة بـ errno.  
• تعرض الدالة perror() السلسلة التي تمررها إليها، متبوعة بنقطتين، ومسافة، ثم التمثيل النصي لقيمة errno الحالية.  
• الدالة strerror()، التي تعيد مؤشرًا إلى التمثيل النصي لقيمة errno الحالية.  
دعنا نحاول محاكاة حالة خطأ ومحاولة فتح ملف غير موجود. هنا أستخدم كلتا الدالتين لإظهار الاستخدام، ولكن يمكنك استخدام طريقة واحدة أو أكثر لطباعة أخطائك. النقطة المهمة الثانية التي يجب ملاحظتها هي أنه يجب عليك استخدام دفق ملف stderr لإخراج جميع الأخطاء.

|  1  \#include \<stdio.h\>  2    3  main()  4  {  5      ...  6    7      if (pf \== NULL)  8      {  9          errnum \= errno; 10          fprintf(stderr, "Value of errno: %d\\n", errno); 11          perror("Error printed by perror"); 12          fprintf(stderr, "Error opening file: %s\\n", strerror( errnum )); 13      } 14      else 15      { 16          fclose (pf); 17      } 18   19      return 0; 20  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of errno: 2 Error printed by perror: No such file or directory Error opening file: No such file or directory |
| :---- |

2. ##  **أخطاء القسمة على صفر**		 {#أخطاء-القسمة-على-صفر}

 أخطاء القسمة على صفر  
إنها مشكلة شائعة أنه في وقت قسمة أي رقم، لا يتحقق المبرمجون مما إذا كان المقسوم عليه صفرًا، وفي النهاية يؤدي ذلك إلى حدوث خطأ وقت التشغيل.  
يعمل الكود أدناه على إصلاح هذه المشكلة من خلال التحقق مما إذا كان المقسوم عليه صفرًا قبل القسمة:

|  1  \#include \<stdio.h\>   2  \#include \<stdlib.h\>  3    4  main()  5  {  6      int dividend \= 20;  7      int divisor \= 0;  8      int quotient;  9   10      if( divisor \== 0) 11      { 12          fprintf(stderr, "Division by zero\! Exiting...\\n"); 13          exit(-1); 14      } 15       16      quotient \= dividend / divisor; 17       18      fprintf(stderr, "Value of quotient : %d\\n", quotient ); 19   20      exit(0); 21  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Division by zero\! Exiting... |
| :---- |

3. ## **خروج البرنامج بقيمة** {#خروج-البرنامج-بقيمة}

من الممارسات الشائعة الخروج بقيمة EXIT\_SUCCESS في حالة خروج البرنامج بعد عملية ناجحة. هنا، EXIT\_SUCCESS عبارة عن ماكرو ويتم تعريفها على أنها 0\.  
إذا كان لديك حالة خطأ في برنامجك وأنت تخرج، فيجب عليك الخروج بحالة EXIT\_FAILURE والتي يتم تعريفها على أنها \-1. لذا، دعنا نكتب البرنامج أعلاه على النحو التالي:

|  1  \#include \<stdio.h\>   2  \#include \<stdlib.h\>  3    4  main()  5  {  6      int dividend \= 20;  7      int divisor \= 5;  8      int quotient;  9   10      if( divisor \== 0) 11      { 12          fprintf(stderr, "Division by zero\! Exiting...\\n"); 13          exit(EXIT\_FAILURE); 14      } 15       16      quotient \= dividend / divisor; 17       18      fprintf(stderr, "Value of quotient : %d\\n", quotient ); 19   20      exit(EXIT\_SUCCESS); 21  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Value of quotient : 4 |
| :---- |

27. # **التكرار**  {#التكرار}

التكرار هو عملية تكرار العناصر بطريقة متشابهة ذاتيًا. في لغات البرمجة، إذا سمح لك البرنامج باستدعاء دالة داخل نفس الدالة، فإن هذا يسمى استدعاءً متكررًا للدالة.

| void recursion() { recursion();       /\* function calls itself \*/ } int main() { recursion(); } |
| :---- |

تدعم لغة البرمجة C التكرار، أي استدعاء دالة ما لنفسها. ولكن أثناء استخدام التكرار، يجب على المبرمجين توخي الحذر عند تحديد شرط الخروج من الدالة، وإلا ستدخل في حلقة لا نهائية.  
تعد الدوال التكرارية مفيدة جدًا لحل العديد من المشكلات الرياضية، مثل حساب عاملي رقم، وتوليد سلسلة فيبوناتشي، وما إلى ذلك.

1. ## **أعداد العامل**		

عامل العدد  
يحسب المثال التالي عامل عدد معين باستخدام دالة متكررة:

|  1  \#include \<stdio.h\>  2    3  int factorial(unsigned int i)  4  {  5      if(i \<= 1)  6      {  7          return 1;  8      }  9   10      return i \* factorial(i \- 1); 11  } 12   13  int main() 14  { 15      int i \= 15; 16   17      printf("Factorial of %d is %d\\n", i, factorial(i)); 18   19      return 0; 20  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| Factorial of 15 is 2004310016 |
| :---- |

2. ## **سلسلة فيبوناتشي** 

 سلسلة فيبوناتشي  
يُنشئ المثال التالي سلسلة فيبوناتشي لرقم معين باستخدام دالة متكررة:

|  1  \#include \<stdio.h\>  2    3  int fibonaci(int i)  4  {  5      if(i \== 0)  6      {  7          return 0;  8      }  9       10      if(i \== 1) 11      { 12          return 1; 13      } 14       15      return fibonaci(i\-1) \+ fibonaci(i\-2); 16  } 17   18   19  int main() 20  { 21      int i; 22       23      for (i \= 0; i \< 10; i\++) 24      { 25          printf("%d\\t%n", fibonaci(i)); 26      } 27       28      return 0; 29  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية:

| 0	1	1	2	3	5	8	13	21	34 |
| :---- |

28. # **دالة يمكنها قبول عدد متغير من المعلمات** {#دالة-يمكنها-قبول-عدد-متغير-من-المعلمات}

في بعض الأحيان، قد تواجه موقفًا عندما تريد الحصول على دالة يمكنها قبول عدد متغير من الوسائط، أي المعلمات، بدلاً من عدد محدد مسبقًا من المعلمات. توفر لغة البرمجة C حلاً لهذا الموقف، حيث يُسمح لك بتعريف دالة يمكنها قبول عدد متغير من المعلمات بناءً على متطلباتك. يوضح المثال التالي تعريف مثل هذه الدالة.

| int func(int, ... ) { . . . }  int main() { func(1, 2, 3); func(1, 2, 3, 4); } |
| :---- |

يجب ملاحظة أن الدالة func() لها آخر معامل لها على هيئة نقاط حذف، أي ثلاث نقاط (...) والمعامل الذي يسبق النقاط الحذفية يكون دائمًا عددًا صحيحًا يمثل العدد الإجمالي لمعاملات المتغيرات التي تم تمريرها. لاستخدام هذه الوظيفة، تحتاج إلى الاستفادة من ملف رأس stdarg.h الذي يوفر الوظائف والماكرو لتنفيذ وظيفة معامل المتغيرات واتباع الخطوات الموضحة:  
1\. قم بتعريف دالة مع آخر معامل لها على هيئة نقاط حذف والمعامل الذي يسبق النقاط الحذفية يكون دائمًا عددًا صحيحًا يمثل عدد المعامل.  
2\. قم بإنشاء متغير من نوع va\_list في تعريف الدالة. يتم تعريف هذا النوع في ملف رأس stdarg.h.  
3\. استخدم معامل int وماكرو va\_start لتهيئة متغير va\_list لقائمة معامل. يتم تعريف الماكرو va\_start في ملف رأس stdarg.h.  
4\. استخدم ماكرو va\_arg ومتغير va\_list للوصول إلى كل عنصر في قائمة المعامل.

5\. استخدم الماكرو va\_end لتنظيف الذاكرة المخصصة لمتغير va\_list.  
الآن دعنا نتبع الخطوات المذكورة أعلاه ونكتب دالة بسيطة يمكنها أخذ عدد المعلمات المتغيرة وإرجاع متوسطها:

|  1  \#include \<stdio.h\>  2  \#include \<stdarg.h\>  3    4  double average(int num,...)  5  {  6      va\_list valist;  7      double sum \= 0.0;  8      int i;  9   10      /\* initialize valist for num number of arguments \*/ 11      va\_start(valist, num); 12   13      /\* access all the arguments assigned to valist \*/ 14      for (i \= 0; i \< num; i\++) 15      { 16          sum \+= va\_arg(valist, int); 17      } 18   19      /\* clean memory reserved for valist \*/ 20      va\_end(valist); 21   22      return sum/num; 23  } 24   25   26  int main() 27  { 28      printf("Average of 2, 3, 4, 5 \= %f\\n", average(4, 2,3,4,5)); 29      printf("Average of 5, 10, 15 \= %f\\n", average(3, 5,10,15)); 30   31      return 0; 32  }  |
| :---- |

عند تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية. تجدر الإشارة إلى أن الدالة average() تم استدعاؤها مرتين وفي كل مرة يمثل الوسيط الأول العدد الإجمالي لوسطاء المتغيرات التي تم تمريرها. سيتم استخدام النقاط الثلاث فقط لتمرير عدد متغير من الوسطاء.

| Average of 2, 3, 4, 5 \= 3.500000 Average of 5, 10, 15 \= 10.000000 |
| :---- |

29. # **إدارة الذاكرة الديناميكية**	 {#إدارة-الذاكرة-الديناميكية}

يوضح هذا الفصل إدارة الذاكرة الديناميكية بلغة C. توفر لغة البرمجة C العديد من الوظائف لتخصيص الذاكرة وإدارتها. يمكن العثور على هذه الوظائف في ملف الرأس \<stdlib.h\>.

| Function | Description |
| :---- | :---- |
| void \*calloc(int num, int size); | This function allocates an array of num elements each of which size in bytes will be size. |
| void free(void \*address); | This function releases a block of memory block specified by address. |
| void \*malloc(int num); | This function allocates an array of num bytes and leave them initialized. |
| void \*realloc(void \*address, int newsize); | This function re-allocates memory extending it upto newsize. |

1. ## **تمرير قيمة حجم أثناء تخصيص الذاكرة**			 {#تمرير-قيمة-حجم-أثناء-تخصيص-الذاكرة}

أثناء البرمجة، إذا كنت على دراية بحجم المصفوفة، فسيكون الأمر سهلاً ويمكنك تعريفها كمصفوفة. على سبيل المثال، لتخزين اسم أي شخص، يمكن أن يصل الحد الأقصى إلى 100 حرف، لذا يمكنك تعريف شيء ما على النحو التالي:

| char name\[100\]; |
| :---- |

ولكن دعنا الآن نفكر في موقف لا تملك فيه أي فكرة عن طول النص الذي تحتاج إلى تخزينه، على سبيل المثال، تريد تخزين وصف تفصيلي لموضوع ما. هنا نحتاج إلى تعريف مؤشر إلى حرف دون تحديد مقدار الذاكرة المطلوبة، وبعد ذلك، بناءً على المتطلبات، يمكننا تخصيص الذاكرة كما هو موضح في المثال أدناه:

|  1  \#include \<stdio.h\>  2  \#include \<stdlib.h\>  3  \#include \<string.h\>  4    5  int main()  6  {  7      char name\[100\];  8      char \*description;  9   10      strcpy(name, "Zara Ali"); 11   12      /\* allocate memory dynamically \*/ 13      description \= malloc( 200 \* sizeof(char) ); 14   15      if( description \== NULL ) 16      { 17          fprintf(stderr, "Error \- unable to allocate required memory\\n"); 18      } 19      else 20      { 21          strcpy( description, "Zara ali a DPS student in class 10th"); 22      } 23   24      printf("Name \= %s\\n", name ); 25      printf("Description: %s\\n", description ); 26   27      return 0; 28  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية.

| Name \= Zara Ali Description: Zara ali a DPS student in class 10th |
| :---- |

يمكن كتابة نفس البرنامج باستخدام calloc(); الشيء الوحيد هو أنك تحتاج إلى استبدال malloc بـ calloc على النحو التالي:

| calloc(200, sizeof(char)); |
| :---- |

وبالتالي، لديك التحكم الكامل ويمكنك تمرير أي قيمة حجم أثناء تخصيص الذاكرة، على عكس المصفوفات حيث بمجرد تحديد الحجم، لا يمكنك تغييره.

2. ## **تحرير كل الذاكرة المخصصة**			 {#تحرير-كل-الذاكرة-المخصصة}

عندما يخرج برنامجك، يقوم نظام التشغيل تلقائيًا بتحرير كل الذاكرة المخصصة بواسطة برنامجك، ولكن كممارسة جيدة عندما لا تكون في حاجة إلى الذاكرة بعد الآن، فيجب عليك تحرير تلك الذاكرة عن طريق استدعاء الدالة free().

بدلاً من ذلك، يمكنك زيادة أو تقليل حجم كتلة الذاكرة المخصصة عن طريق استدعاء الدالة realloc(). دعنا نتحقق من البرنامج أعلاه مرة أخرى ونستفيد من الدالتين realloc() وfree():

|  1  \#include \<stdio.h\>  2  \#include \<stdlib.h\>  3  \#include \<string.h\>  4    5  int main()  6  {  7      char name\[100\];  8      char \*description;  9   10      strcpy(name, "Zara Ali"); 11   12      /\* allocate memory dynamically \*/ 13      description \= malloc( 30 \* sizeof(char) ); 14   15      if( description \== NULL ) 16      { 17          fprintf(stderr, "Error \- unable to allocate required memory\\n"); 18      } 19      else 20      { 21          strcpy( description, "Zara ali a DPS student."); 22      } 23   24      /\* suppose you want to store bigger description \*/ 25      description \= realloc( description, 100 \* sizeof(char) ); 26   27      if( description \== NULL ) 28      { 29          fprintf(stderr, "Error \- unable to allocate required memory\\n"); 30      } 31      else 32      { 33          strcat( description, "She is in class 10th"); 34      } 35   36      printf("Name \= %s\\n", name ); 37      printf("Description: %s\\n", description ); 38   39      /\* release memory using free() function \*/ 40      free(description); 41   42      return 0; 43  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه، فإنه ينتج النتيجة التالية.

| Name \= Zara Ali Description: Zara ali a DPS student.She is in class 10th |
| :---- |

يمكنك تجربة المثال أعلاه دون إعادة تخصيص ذاكرة إضافية، وستعطي دالة strcat() خطأ بسبب نقص الذاكرة المتاحة في الوصف.

30. # **تمرير القيم من سطر الأوامر إلى برامج C**	 {#تمرير-القيم-من-سطر-الأوامر-إلى-برامج-c}

من الممكن تمرير بعض القيم من سطر الأوامر إلى برامج C الخاصة بك عند تنفيذها. تسمى هذه القيم وسيطات سطر الأوامر وفي كثير من الأحيان تكون مهمة لبرنامجك خاصة عندما تريد التحكم في برنامجك من الخارج بدلاً من ترميز هذه القيم داخل الكود.  
يتم التعامل مع وسيطات سطر الأوامر باستخدام وسيطات دالة main() حيث يشير argc إلى عدد الوسيطات التي تم تمريرها، وargv\[\] عبارة عن مصفوفة مؤشرات تشير إلى كل وسيطة تم تمريرها إلى البرنامج. فيما يلي مثال بسيط يتحقق مما إذا كان هناك أي وسيطة تم توفيرها من سطر الأوامر ويتخذ الإجراء وفقًا لذلك:

|  1  \#include \<stdio.h\>  2    3  int main( int argc, char \*argv\[\] )  4  {  5      if( argc \== 2 )  6      {  7          printf("The argument supplied is %s\\n", argv\[1\]);  8      }  9      else if( argc \> 2 ) 10      { 11          printf("Too many arguments supplied.\\n"); 12      } 13      else 14      { 15          printf("One argument expected.\\n"); 16      } 17       18      return 0; 19  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه بحجة واحدة، فإنه ينتج النتيجة التالية.

| $./a.out testing The argument supplied is testing |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه باستخدام وسيطتين، فإنه ينتج النتيجة التالية.

| $./a.out testing1 testing2 Too many arguments supplied. |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه دون تمرير أي وسيطة، فإنه ينتج النتيجة التالية.

| $./a.out One argument expected |
| :---- |

يجب ملاحظة أن argv\[0\] يحمل اسم البرنامج نفسه وargv\[1\] هو مؤشر إلى وسيطة سطر الأوامر الأولى المقدمة، و  
\*argv\[n\] هي الوسيطة الأخيرة. إذا لم يتم تقديم أي وسيطات، فسيكون argc واحدًا، وإذا مررت وسيطة واحدة، فسيتم تعيين argc على 2\.  
تمرر جميع وسيطات سطر الأوامر مفصولة بمسافة، ولكن إذا كانت الوسيطة نفسها تحتوي على مسافة، فيمكنك تمرير مثل هذه الوسائط عن طريق وضعها بين علامتي اقتباس مزدوجتين "" أو اقتباس مفردة ''. دعنا نعيد كتابة المثال أعلاه مرة أخرى حيث سنطبع اسم البرنامج ونمرر أيضًا وسيطة سطر أوامر عن طريق وضعها بين علامتي اقتباس مزدوجتين:

|  1  \#include \<stdio.h\>  2    3  int main( int argc, char \*argv\[\] )  4  {  5      printf("Program name %s\\n", argv\[0\]);  6    7      if( argc \== 2 )  8      {  9          printf("The argument supplied is %s\\n", argv\[1\]); 10      } 11      else if( argc \> 2 ) 12      { 13          printf("Too many arguments supplied.\\n"); 14      } 15      else 16      { 17          printf("One argument expected.\\n"); 18      } 19       20      return 0; 21  }  |
| :---- |

عندما يتم تجميع الكود أعلاه وتنفيذه بحجة واحدة مفصولة بمسافة ولكن داخل علامتي اقتباس مزدوجتين، فإنه ينتج النتيجة التالية.

| $./a.out "testing1 testing2"  Progranm name ./a.out The argument supplied is testing1 testing2 |
| ----- |

